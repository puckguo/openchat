<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open CoChat - å¤šäººåä½œèŠå¤©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
        }
        .card {
            background: #252525;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        .card h2 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #fff;
            font-size: 14px;
        }
        input, select {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
            color: #fff;
            font-size: 14px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #666;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .btn-primary {
            background: #444;
            color: #fff;
        }
        .btn-primary:hover {
            background: #555;
        }
        .btn-danger {
            background: #666;
            color: #fff;
        }
        .btn-danger:hover {
            background: #777;
        }
        .btn-secondary {
            background: #555;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #666;
        }
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .status-connected {
            background: #44444433;
            color: #aaa;
        }
        .status-disconnected {
            background: #33333333;
            color: #fff;
        }
        .status-connecting {
            background: #55555533;
            color: #999;
        }
        .upload-area {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover {
            border-color: #666;
            background: #33333333;
        }
        .file-message {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #333;
            border-radius: 8px;
            margin-top: 5px;
        }
        .file-icon {
            font-size: 32px;
        }
        .file-info {
            flex: 1;
            min-width: 0;
        }
        .file-name {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #fff;
        }
        .file-size {
            font-size: 12px;
            color: #fff;
        }
        .file-download {
            color: #aaa;
            text-decoration: none;
            padding: 6px 12px;
            background: #333;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s;
        }
        .file-download:hover {
            background: #555;
            color: #fff;
        }
        .chat-container {
            height: 400px;
            background: #1e3a1e;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            margin-bottom: 15px;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        /* å…¨å±æ¨¡å¼æ ·å¼ */
        .fullscreen-mode {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1000;
            border-radius: 0 !important;
            margin: 0 !important;
            max-width: none !important;
        }
        .fullscreen-mode .chat-container {
            height: calc(100vh - 180px) !important;
            max-height: none !important;
        }
        .fullscreen-mode .chat-layout {
            height: calc(100vh - 150px);
        }
        .fullscreen-mode .chat-main {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #voice-ai-panel.fullscreen-mode {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1000;
            border-radius: 0 !important;
            margin: 0 !important;
            display: flex;
            flex-direction: column;
        }
        #voice-ai-panel.fullscreen-mode #voice-ai-chat-area {
            max-height: none !important;
            flex: 1;
            height: calc(100vh - 200px);
        }
        #shared-ai-panel.fullscreen-mode {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1000;
            border-radius: 0 !important;
            margin: 0 !important;
            display: flex;
            flex-direction: column;
        }
        #shared-ai-panel.fullscreen-mode #shared-ai-chat-area {
            max-height: none !important;
            flex: 1;
            height: calc(100vh - 200px);
        }
        .expand-btn {
            font-size: 16px;
            padding: 6px 12px;
            margin-left: 10px;
        }
        .copy-btn {
            font-size: 12px;
            padding: 4px 10px;
            margin-left: 8px;
            background: #4a4a4a;
        }
        .copy-btn:hover {
            background: #5a5a5a;
        }
        .copy-btn.copied {
            background: #4caf50;
        }
        /* æŠ˜å é¢æ¿æ ·å¼ */
        .collapsible-panel {
            transition: all 0.3s ease;
        }
        .collapsible-panel.collapsed {
            max-height: 80px;
            overflow: visible;
        }
        .collapsible-panel.collapsed .panel-content {
            display: none;
        }
        /* æŠ˜å é¢æ¿æ ‡é¢˜æ  */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header-left {
            display: flex;
            align-items: center;
        }
        .panel-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .collapse-btn {
            font-size: 14px;
            padding: 4px 10px;
            margin-left: 10px;
        }
        /* èŠå¤©å¸ƒå±€ - ä¸»åŒºåŸŸ + ä¾§è¾¹æ  */
        .chat-layout {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        .chat-main {
            flex: 1;
            min-width: 0;
        }
        .chat-main .chat-container {
            margin-bottom: 0;
        }
        .chat-sidebar {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .sidebar-section {
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            background: #333;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            border-bottom: 1px solid #444;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            max-height: 200px;
        }
        .sidebar-empty {
            color: #666;
            font-size: 12px;
            text-align: center;
            padding: 20px 10px;
        }
        .sidebar-item {
            padding: 8px 10px;
            margin-bottom: 8px;
            background: #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            border-left: 3px solid transparent;
        }
        .sidebar-item:hover {
            background: #333;
            border-left-color: #666;
        }
        .sidebar-item-mention {
            border-left-color: #fff;
        }
        .sidebar-item-ai {
            border-left-color: #aaa;
        }
        .sidebar-item-sender {
            font-weight: bold;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 11px;
        }
        .sidebar-item-preview {
            color: #fff;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .sidebar-item-time {
            color: #666;
            font-size: 10px;
            margin-top: 4px;
        }
        /* AIæ¶ˆæ¯æŠ˜å æ ·å¼ */
        .ai-content-collapsed {
            position: relative;
        }
        .ai-content-preview {
            display: inline;
        }
        .ai-content-full {
            display: none;
        }
        .ai-content-expanded .ai-content-preview {
            display: none;
        }
        .ai-content-expanded .ai-content-full {
            display: block;
        }
        .ai-expand-btn {
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            margin-left: 5px;
            text-decoration: underline;
        }
        .ai-expand-btn:hover {
            color: #aaa;
        }
        /* ç§»åŠ¨ç«¯å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            .chat-layout {
                flex-direction: column;
            }
            .chat-sidebar {
                width: 100%;
                flex-direction: row;
                gap: 10px;
            }
            .sidebar-section {
                flex: 1;
                min-width: 0;
            }
            .sidebar-content {
                max-height: 150px;
            }
            .chat-main .chat-container {
                height: 300px;
            }
            .chat-container {
                height: 300px;
            }
        }
        .message {
            margin-bottom: 12px;
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .message-own {
            background: #44444444;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        .message-other {
            background: #33333344;
            border-bottom-left-radius: 4px;
        }
        .message-ai {
            background: #3a3a3a;
            border: 1px solid #555;
            border-bottom-left-radius: 4px;
            max-width: 90%;
        }
        .message-ai .message-header {
            color: #fff;
            font-weight: bold;
        }
        .message-ai .message-content {
            line-height: 1.6;
        }
        .message-ai .message-content code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        .message-ai .message-content pre {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .message-ai .message-content pre code {
            background: transparent;
            padding: 0;
        }
        .message-system {
            background: #44444433;
            text-align: center;
            margin: 10px auto;
            font-size: 12px;
            color: #fff;
        }
        .message-header {
            font-size: 12px;
            color: #fff;
            margin-bottom: 4px;
        }
        .message-content {
            font-size: 14px;
            line-height: 1.5;
        }
        .mention {
            color: #aaa;
            font-weight: bold;
        }
        .input-group {
            display: flex;
            gap: 10px;
        }
        .input-group input {
            flex: 1;
        }
        .participants {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .participant {
            background: #333;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .participant-role {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .role-owner { background: #888; }
        .role-admin { background: #666; }
        .role-member { background: #555; }
        .role-guest { background: #888; }
        .log {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #fff;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
            border-bottom: 1px solid #333;
        }
        .log-time {
            color: #666;
        }
        .hidden {
            display: none;
        }
        .flex {
            display: flex;
            gap: 10px;
        }
        .flex-1 {
            flex: 1;
        }
        .load-more-container {
            text-align: center;
            padding: 10px;
            margin-bottom: 10px;
        }
        .load-more-btn {
            background: #333;
            color: #aaa;
            border: 1px solid #555;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        .load-more-btn:hover:not(:disabled) {
            background: #444;
            color: #fff;
        }
        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #444;
            border-top: 2px solid #888;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .history-divider {
            text-align: center;
            padding: 10px;
            margin: 15px 0;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            color: #fff;
            font-size: 12px;
            background: #2a2a2a;
        }
        /* ä»»åŠ¡è¿›åº¦æ ·å¼ */
        .task-progress-container {
            margin-top: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
        }
        .task-progress-header {
            background: #333;
            padding: 10px 15px;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .task-progress-header:hover {
            background: #3a3a3a;
        }
        .task-progress-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .task-progress-bar-container {
            height: 4px;
            background: #444;
            overflow: hidden;
        }
        .task-progress-bar {
            height: 100%;
            background: #666;
            transition: width 0.3s ease;
        }
        .task-progress-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px 15px;
        }
        .task-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        .task-item:last-child {
            border-bottom: none;
        }
        .task-status-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .task-status-pending {
            background: #444;
            color: #888;
        }
        .task-status-in_progress {
            background: #3a5a3a;
            color: #8f8;
            animation: pulse 1.5s infinite;
        }
        .task-status-completed {
            background: #3a3a;
            color: #8f8;
        }
        .task-status-failed {
            background: #5a3a3a;
            color: #f88;
        }
        .task-status-skipped {
            background: #444;
            color: #888;
        }
        .task-info {
            flex: 1;
            min-width: 0;
        }
        .task-title {
            font-size: 13px;
            color: #fff;
            margin-bottom: 2px;
        }
        .task-description {
            font-size: 11px;
            color: #888;
        }
        .task-result {
            font-size: 11px;
            color: #aaa;
            margin-top: 4px;
            padding: 4px 8px;
            background: #2a2a2a;
            border-radius: 4px;
        }
        .task-error {
            font-size: 11px;
            color: #f88;
            margin-top: 4px;
            padding: 4px 8px;
            background: #3a2a2a;
            border-radius: 4px;
        }
        .task-progress-empty {
            color: #666;
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
    </style>
    <!-- QRCode.js ç”¨äºç”ŸæˆäºŒç»´ç  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Open CoChat</h1>
        <p class="subtitle">å¤šäººå®æ—¶åä½œèŠå¤©å®¤ | @AI æ™ºèƒ½åŠ©æ‰‹ | æ–‡ä»¶åˆ†äº«</p>

        <!-- è¿æ¥é…ç½® -->
        <div class="card" id="config-card">
            <h2>è¿æ¥é…ç½®</h2>
            <div class="flex">
                <div class="form-group flex-1">
                    <label>æœåŠ¡å™¨åœ°å€</label>
                    <input type="text" id="server-url" value="" placeholder="è‡ªåŠ¨æ£€æµ‹">
                </div>
                <div class="form-group flex-1">
                    <label>ä¼šè¯ ID</label>
                    <input type="text" id="session-id" value="test-session" placeholder="session-id">
                </div>
            </div>
            <!-- ç”¨æˆ·åå•ç‹¬ä¸€è¡Œ -->
            <div class="form-group">
                <label>ç”¨æˆ·å <span style="color: #fff;">*</span></label>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="user-name" value="" placeholder="è¯·è¾“å…¥ç”¨æˆ·å" style="flex: 1;">
                    <button class="btn btn-secondary" onclick="generateRandomName()" title="éšæœºç”Ÿæˆ" style="white-space: nowrap;">ğŸ² éšæœº</button>
                </div>
            </div>
            <div class="flex">
                <div class="form-group flex-1">
                    <label>è§’è‰²</label>
                    <select id="user-role" onchange="onRoleChange()">
                        <option value="owner">Owner</option>
                        <option value="admin">Admin</option>
                        <option value="member" selected>Member</option>
                        <option value="guest">Guest</option>
                    </select>
                </div>
                <div class="form-group flex-1">
                    <label>Supabase Token (å¯é€‰ï¼Œç”¨äºè®¤è¯)</label>
                    <input type="text" id="auth-token" placeholder="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...">
                </div>
            </div>
            <!-- è§’è‰²å¯†ç è¾“å…¥æ¡†ï¼ˆä»…Ownerå’ŒAdminæ˜¾ç¤ºï¼‰ -->
            <div class="form-group hidden" id="role-password-group">
                <label style="color: #fff;">è§’è‰²å¯†ç  <span style="color: #666; font-size: 12px;">(Owner/Adminåˆ›å»ºå¸¦å¯†ç æˆ¿é—´éœ€è¦)</span></label>
                <input type="password" id="role-password" placeholder="è¯·è¾“å…¥è§’è‰²å¯†ç ">
            </div>
            <hr style="border-color: #444; margin: 20px 0;">
            <p style="color: #fff; font-size: 12px; margin-bottom: 10px;">åˆ›å»ºèŠå¤©å®¤æ—¶è®¾ç½®å¯†ç é—®é¢˜ï¼ˆå¯é€‰ï¼Œä»…Ownerå’ŒAdminå¯è®¾ç½®ï¼‰</p>
            <div class="flex">
                <div class="form-group flex-1">
                    <label>å¯†ç é—®é¢˜ï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="password-question" placeholder="ä¾‹å¦‚ï¼šä»Šå¤©çš„æ—¥æœŸæ˜¯ï¼Ÿ">
                </div>
                <div class="form-group flex-1">
                    <label>å¯†ç ç­”æ¡ˆï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="password-answer" placeholder="è®¾ç½®è¿›å…¥èŠå¤©å®¤çš„å¯†ç ç­”æ¡ˆ">
                </div>
            </div>
            <div>
                <button class="btn btn-primary" onclick="connect()">è¿æ¥</button>
                <button class="btn btn-danger hidden" id="disconnect-btn" onclick="disconnect()">æ–­å¼€</button>
                <span class="status status-disconnected" id="connection-status">æœªè¿æ¥</span>
            </div>
        </div>

        <!-- å¯†ç éªŒè¯ç•Œé¢ -->
        <div class="card hidden" id="password-card">
            <h2>è¾“å…¥å¯†ç ç­”æ¡ˆ</h2>
            <p style="color: #fff; margin-bottom: 15px;">æ­¤èŠå¤©å®¤éœ€è¦å¯†ç æ‰èƒ½è¿›å…¥</p>
            <div class="form-group">
                <label>å¯†ç é—®é¢˜</label>
                <div id="password-question-display" style="padding: 10px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333; color: #fff;"></div>
            </div>
            <div class="form-group">
                <label>ä½ çš„ç­”æ¡ˆ</label>
                <input type="text" id="password-answer-input" placeholder="è¯·è¾“å…¥ç­”æ¡ˆ...">
            </div>
            <div>
                <button class="btn btn-primary" onclick="submitPassword()">æäº¤ç­”æ¡ˆ</button>
                <button class="btn btn-danger" onclick="disconnect()">å–æ¶ˆ</button>
            </div>
        </div>

        <!-- èŠå¤©ç•Œé¢ -->
        <div class="card hidden collapsible-panel" id="chat-card">
            <div class="panel-header" style="margin-bottom: 15px;">
                <div class="panel-header-left">
                    <h2 style="margin: 0;">èŠå¤©å®¤ <span id="room-name"></span></h2>
                    <button class="btn btn-secondary collapse-btn" onclick="toggleChatCollapse()" title="æŠ˜å /å±•å¼€" id="chat-collapse-btn">â–¼</button>
                    <button class="btn btn-secondary copy-btn" onclick="copyChatHistory()" title="å¤åˆ¶èŠå¤©è®°å½•">ğŸ“‹ å¤åˆ¶</button>
                </div>
                <div class="panel-header-right">
                    <button class="btn btn-secondary expand-btn" onclick="toggleChatFullscreen()" title="å…¨å±å±•å¼€">â›¶</button>
                </div>
            </div>
            <div class="panel-content" id="chat-panel-content">

            <div class="participants" id="participants">
                <!-- å‚ä¸è€…åˆ—è¡¨ -->
            </div>

            <div class="chat-layout">
                <!-- å·¦ä¾§ï¼šèŠå¤©åŒºåŸŸ -->
                <div class="chat-main">
                    <div class="chat-container" id="chat-container">
                        <div class="load-more-container" id="load-more-container" style="display: none;">
                            <button class="load-more-btn" id="load-more-btn" onclick="loadMoreHistory()">
                                åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
                            </button>
                        </div>
                        <!-- æ¶ˆæ¯åˆ—è¡¨ -->
                    </div>

                    <div class="input-group">
                        <input type="text" id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯... ä½¿ç”¨ @ai æåŠ" onkeypress="handleKeyPress(event)">
                        <button class="btn btn-primary" onclick="sendMessage()">å‘é€</button>
                    </div>

                    <div style="margin-top: 15px;">
                        <button class="btn btn-secondary" id="btn-ai-mention" onclick="handleAIButtonClick(event)" ontouchstart="startAIButtonASR(event)" ontouchend="stopAIButtonASR()" onmousedown="startAIButtonASR(event)" onmouseup="stopAIButtonASR()" onmouseleave="stopAIButtonASR()">@AI</button>
                        <input type="file" id="file-input" style="display: none;" onchange="handleFileSelect(event)">
                        <button class="btn btn-secondary" onclick="document.getElementById('file-input').click()">é€‰æ‹©æ–‡ä»¶</button>
                        <button class="btn btn-secondary" onclick="clearAIMemory()">æ¸…ç©ºAIè®°å¿†</button>
                        <button class="btn btn-secondary" onclick="clearChat()">æ¸…ç©º</button>
                        <button id="btn-auto-scroll" onclick="toggleAutoScroll()" style="background: #28a745; color: #fff;">è‡ªåŠ¨æ»šåŠ¨</button>
                    </div>

                    <!-- AI ä»»åŠ¡è¿›åº¦æ˜¾ç¤º -->
                    <div class="task-progress-container hidden" id="task-progress-container">
                        <div class="task-progress-header" onclick="toggleTaskProgress()">
                            <div class="task-progress-title">
                                <span>ğŸ“‹</span>
                                <span id="task-progress-title-text">AI ä»»åŠ¡æ‰§è¡Œä¸­</span>
                            </div>
                            <div>
                                <span id="task-progress-percent">0%</span>
                                <span id="task-progress-toggle" style="margin-left: 8px;">â–¼</span>
                            </div>
                        </div>
                        <div class="task-progress-bar-container">
                            <div class="task-progress-bar" id="task-progress-bar" style="width: 0%"></div>
                        </div>
                        <div class="task-progress-content" id="task-progress-content">
                            <div class="task-progress-empty">ç­‰å¾…ä»»åŠ¡...</div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§ï¼š@æåŠå’ŒAIå›å¤åŒºåŸŸ -->
                <div class="chat-sidebar">
                    <!-- ä¸Šéƒ¨ï¼š@æåŠæ¶ˆæ¯ -->
                    <div class="sidebar-section">
                        <div class="sidebar-header">@æåŠæ¶ˆæ¯</div>
                        <div class="sidebar-content" id="mentions-list">
                            <div class="sidebar-empty">æš‚æ— @æåŠæ¶ˆæ¯</div>
                        </div>
                    </div>
                    <!-- ä¸‹éƒ¨ï¼šAIå›å¤ -->
                    <div class="sidebar-section">
                        <div class="sidebar-header">AIå›å¤</div>
                        <div class="sidebar-content" id="ai-responses-list">
                            <div class="sidebar-empty">æš‚æ— AIå›å¤</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¯­éŸ³èŠå¤©æ§åˆ¶æ  -->
            <div id="voice-chat-panel" style="margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                    <div style="font-weight: bold; color: #fff;">
                        ğŸ™ï¸ è¯­éŸ³èŠå¤©+æ–‡å­—AI
                        <span id="voice-status" class="status status-disconnected" style="margin-left: 10px;">æœªè¿æ¥</span>
                    </div>
                    <div>
                        <button class="btn btn-primary" id="btn-voice-join" onclick="joinVoiceChat()">åŠ å…¥è¯­éŸ³</button>
                        <button class="btn hidden" id="btn-voice-mute" onclick="toggleVoiceChatMute()" style="background: #28a745; color: #fff;">ğŸ¤ å¼€éº¦</button>
                        <button class="btn btn-danger hidden" id="btn-voice-leave" onclick="leaveVoiceChat()">ç¦»å¼€è¯­éŸ³</button>
                    </div>
                </div>
                <div id="voice-https-warning" style="color: #fff; font-size: 12px; margin-bottom: 10px; padding: 8px; background: #33333333; border-radius: 4px;">
                    âš ï¸ å®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚è¯·ä½¿ç”¨ https:// è®¿é—®æ­¤é¡µé¢ã€‚
                </div>
                <div id="voice-https-ok" style="display: none; color: #666; font-size: 12px; margin-bottom: 10px; padding: 8px; background: #66620; border-radius: 4px;">
                    âœ… å·²ä½¿ç”¨ HTTPSï¼Œè¯­éŸ³åŠŸèƒ½å®Œå…¨å¯ç”¨
                </div>
                <div id="voice-participants" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">
                    <!-- è¯­éŸ³å‚ä¸è€…åˆ—è¡¨ -->
                </div>
                <div id="voice-transcript-area" style="max-height: 150px; overflow-y: auto; background: #2a2a2a; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: none;">
                    <div style="font-size: 12px; color: #fff; margin-bottom: 5px;">å®æ—¶è½¬å½•</div>
                    <div id="voice-transcript-content"></div>
                </div>
                <div id="voice-controls" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div id="vad-indicator" style="display: flex; align-items: center; gap: 8px;">
                            <span id="vad-status-dot" style="display: inline-block; width: 12px; height: 12px; background: #888; border-radius: 50%; transition: all 0.3s;"></span>
                            <span id="vad-status-text" style="color: #fff; font-size: 14px;">æœªæ£€æµ‹åˆ°è¯­éŸ³</span>
                        </div>
                        <div id="voice-speaking-indicator" style="display: none;">
                            <span style="display: inline-block; width: 12px; height: 12px; background: #666; border-radius: 50%; animation: pulse 1s infinite;"></span>
                            <span style="color: #fff; margin-left: 5px;">æ­£åœ¨è¯†åˆ«...</span>
                        </div>
                    </div>
                    <div style="margin-top: 10px; color: #666; font-size: 12px;">
                        ğŸ’¡ åŠ å…¥è¯­éŸ³åè‡ªåŠ¨æŒç»­é‡‡é›†ï¼Œæ£€æµ‹åˆ°è¯­éŸ³è‡ªåŠ¨å¼€å§‹è¯†åˆ«
                    </div>
                </div>
                <div id="voice-error" style="color: #fff; font-size: 12px; margin-top: 10px; display: none;"></div>

                <!-- èŠå¤©å®¤è¯­éŸ³AIåŠŸèƒ½ï¼ˆåŠ å…¥è¯­éŸ³åæ˜¾ç¤ºï¼‰ -->
                <div id="chat-voice-ai-section" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                    <div style="font-weight: bold; color: #fff; margin-bottom: 10px;">
                        ğŸ¤– å®æ—¶è¯­éŸ³AI
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-primary" id="btn-chat-voice-ai" onclick="toggleChatVoiceAI()">ğŸ¤ å¼€å¯è¯­éŸ³AI</button>
                        <button class="btn hidden" id="btn-chat-voice-ai-mode" onclick="toggleChatVoiceAIMode()" style="background: #6c757d; color: #fff;">ğŸ”” å”¤é†’æ¨¡å¼</button>
                    </div>
                    <div id="chat-voice-ai-status" style="display: none; padding: 10px; background: #2a2a2a; border-radius: 8px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span id="chat-voice-ai-indicator" style="display: inline-block; width: 12px; height: 12px; background: #28a745; border-radius: 50%; animation: pulse 1s infinite;"></span>
                            <span id="chat-voice-ai-status-text" style="color: #fff; font-size: 14px;">ğŸ¤ ç›‘å¬ä¸­ - è¯´"AI"å¼€å§‹å¯¹è¯</span>
                        </div>
                        <div id="chat-voice-ai-transcript" style="margin-top: 8px; padding: 8px; background: #1a1a1a; border-radius: 4px; color: #aaa; font-size: 13px; display: none;"></div>
                    </div>
                </div>
            </div>
            <style>
                @keyframes pulse {
                    0% { opacity: 1; transform: scale(1); }
                    50% { opacity: 0.5; transform: scale(1.2); }
                    100% { opacity: 1; transform: scale(1); }
                }
                .voice-participant {
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    padding: 4px 10px;
                    background: #2a2a2a;
                    border-radius: 20px;
                    font-size: 12px;
                }
                .voice-participant.speaking {
                    background: #44444444;
                    border: 1px solid #666;
                }
                .voice-transcript-item {
                    padding: 5px 0;
                    border-bottom: 1px solid #333;
                    font-size: 13px;
                }
                .voice-transcript-item:last-child {
                    border-bottom: none;
                }
                .voice-transcript-speaker {
                    color: #fff;
                    font-weight: bold;
                }
                .voice-transcript-text {
                    color: #fff;
                }
                .voice-transcript-final {
                    opacity: 0.8;
                }
            </style>

            <div id="summary-display" style="margin-top: 10px; display: none; padding: 10px; background: #2a2a2a; border-radius: 8px; border-left: 3px solid #666;">
                <div style="font-weight: bold; color: #fff; margin-bottom: 5px;">å¯¹è¯æ€»ç»“</div>
                <div id="summary-content" style="font-size: 13px; line-height: 1.5; color: #ccc;"></div>
            </div>
            <div id="upload-progress" style="margin-top: 10px; display: none;">
                <div style="background: #333; border-radius: 4px; height: 20px; overflow: hidden;">
                    <div id="upload-bar" style="background: #666; height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
                <span id="upload-status" style="font-size: 12px; color: #fff;"></span>
            </div>
            </div> <!-- panel-content end -->
        </div>

        <!-- å…±äº«è¯­éŸ³AIæ§åˆ¶æ  -->
        <div id="shared-ai-panel" class="card hidden collapsible-panel" style="margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">
            <div class="panel-header" style="margin-bottom: 10px; flex-wrap: wrap;">
                <div class="panel-header-left">
                    <div style="font-weight: bold; color: #fff;">
                        ğŸ™ï¸ğŸ¤– è¯­éŸ³èŠå¤©+å®æ—¶è¯­éŸ³AI
                        <span id="shared-ai-status" class="status status-disconnected" style="margin-left: 10px;">æœªåŠ å…¥</span>
                    </div>
                    <button class="btn btn-secondary collapse-btn" onclick="toggleSharedAICollapse()" title="æŠ˜å /å±•å¼€" id="shared-ai-collapse-btn">â–¼</button>
                </div>
                <div class="panel-header-right" style="flex-wrap: wrap; margin-top: 8px;">
                    <button class="btn btn-primary" id="btn-shared-ai-join" onclick="joinSharedAI()">åŠ å…¥</button>
                    <button class="btn hidden" id="btn-shared-ai-mute" onclick="toggleSharedAIMute()" style="background: #28a745; color: #fff;">ğŸ¤ å¼€éº¦</button>
                    <button class="btn btn-danger hidden" id="btn-shared-ai-leave" onclick="leaveSharedAI()">ç¦»å¼€</button>
                    <button class="btn btn-secondary" id="btn-shared-ai-save" onclick="saveSharedAIChat()" style="display: none;">ğŸ’¾ ä¿å­˜</button>
                    <button class="btn btn-secondary" id="btn-shared-ai-clear" onclick="clearSharedAIChat()" style="display: none;">ğŸ—‘ï¸ æ¸…ç©º</button>
                    <button class="btn btn-secondary expand-btn" onclick="toggleSharedAIFullscreen()" title="å…¨å±å±•å¼€">â›¶</button>
                </div>
            </div>
            <div class="panel-content" id="shared-ai-panel-content">
            <div id="shared-ai-state-display" style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; display: none;">
                <span id="shared-ai-state-dot" style="display: inline-block; width: 12px; height: 12px; background: #888; border-radius: 50%; transition: all 0.3s;"></span>
                <span id="shared-ai-state-text" style="color: #fff; font-size: 14px;">ç©ºé—²</span>
            </div>
            <div id="shared-ai-speaker-display" style="display: none; margin-bottom: 10px;">
                <span id="shared-ai-speaker" style="color: #fff; font-size: 14px;"></span>
            </div>
            <div id="shared-ai-participants" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">
                <!-- å‚ä¸è€…åˆ—è¡¨ -->
            </div>
            <div id="shared-ai-transcript-area" style="max-height: 100px; overflow-y: auto; background: #2a2a2a; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="font-size: 12px; color: #fff; margin-bottom: 5px;">å½“å‰è¯´è¯</div>
                <div id="shared-ai-transcript-content" style="color: #fff; font-size: 14px;"></div>
            </div>
            <!-- èŠå¤©è®°å½•åŒºåŸŸ -->
            <div id="shared-ai-chat-area" style="max-height: 200px; overflow-y: auto; background: #1e2a1e; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 8px;">
                    <div style="font-size: 12px; color: #aaa;">ğŸ’¬ å¯¹è¯è®°å½•</div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary copy-btn" onclick="copySharedAIChat(event)" title="å¤åˆ¶å¯¹è¯è®°å½•" style="font-size: 11px; padding: 3px 8px;">ğŸ“‹ å¤åˆ¶</button>
                        <button class="btn btn-secondary" onclick="exportSharedAIChat()" title="å¯¼å‡ºå¯¹è¯è®°å½•" style="font-size: 11px; padding: 3px 8px;">ğŸ“„ å¯¼å‡º</button>
                    </div>
                </div>
                <div id="shared-ai-chat-messages" style="display: flex; flex-direction: column; gap: 8px;">
                    <div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">å¼€å§‹å¯¹è¯åï¼ŒèŠå¤©è®°å½•å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
                </div>
            </div>
            <div id="shared-ai-response-area" style="max-height: 150px; overflow-y: auto; background: #2a2a2a; border-radius: 8px; padding: 10px; display: none;">
                <div style="font-size: 12px; color: #fff; margin-bottom: 5px;">AIå›å¤</div>
                <div id="shared-ai-response-content" style="color: #fff; font-size: 14px; line-height: 1.5;"></div>
            </div>

            <!-- ä¸Šä¸‹æ–‡æ–‡ä»¶åˆ—è¡¨ -->
            <div id="shared-ai-context-files" style="margin-top: 10px;"></div>

            <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
            <div id="shared-ai-file-upload" style="margin-top: 15px; padding: 12px; background: #1a1a1a; border-radius: 8px; border: 2px dashed #4caf50;">
                <div style="font-size: 12px; color: #0f0; margin-bottom: 4px;">âœ“ æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å·²å¯ç”¨</div>

                <!-- æ–‡ä»¶ä¸Šä¼  -->
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 12px; color: #888; margin-bottom: 8px;">ğŸ“ é€‰æ‹©æ–‡ä»¶</div>
                    <input type="file" id="shared-ai-file-input" style="display: none;" onchange="handleSharedAIFileSelect(event)" accept=".txt,.md,.js,.ts,.py,.json,.yaml,.yml,.xml,.html,.css">
                    <button class="btn btn-secondary" onclick="document.getElementById('shared-ai-file-input').click()" style="font-size: 12px; padding: 6px 12px;">é€‰æ‹©æ–‡ä»¶</button>
                    <span id="shared-ai-file-hint" style="font-size: 11px; color: #666; margin-left: 10px;">æ”¯æŒæ–‡æœ¬æ–‡ä»¶ (æœ€å¤§ 1MB)</span>
                </div>

                <!-- ç²˜è´´æ–‡æœ¬ -->
                <div style="border-top: 1px solid #333; padding-top: 12px;">
                    <div style="font-size: 12px; color: #888; margin-bottom: 8px;">ğŸ“ æˆ–ç²˜è´´æ–‡æœ¬å†…å®¹</div>
                    <input type="text" id="shared-ai-paste-filename" placeholder="æ–‡ä»¶åï¼ˆå¯é€‰ï¼Œå¦‚ï¼šnotes.txtï¼‰" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 4px; margin-bottom: 8px; font-size: 12px;">
                    <textarea id="shared-ai-paste-content" placeholder="åœ¨æ­¤ç²˜è´´æ–‡æœ¬å†…å®¹..." style="width: 100%; height: 80px; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 4px; resize: vertical; font-size: 12px;"></textarea>
                    <button class="btn btn-secondary" onclick="addSharedAIPastedText()" style="margin-top: 8px; font-size: 12px; padding: 6px 12px;">æ·»åŠ æ–‡æœ¬</button>
                </div>
            </div>

            <div style="margin-top: 10px; color: #666; font-size: 12px;">
                ğŸ’¡ åŠ å…¥å…±äº«AIåï¼Œæˆ¿é—´å†…æ‰€æœ‰äººå¯ä»¥ä¸€èµ·ä¸AIå¯¹è¯ã€‚AIä¼šè¯†åˆ«æ¯ä¸ªäººçš„å£°éŸ³å¹¶å›å¤æ‰€æœ‰äººã€‚
            </div>
            </div> <!-- shared-ai panel-content end -->
        </div>

        <!-- è¯­éŸ³AIæ§åˆ¶æ ï¼ˆç‹¬ç«‹äºèŠå¤©å®¤ï¼‰ -->
        <div id="voice-ai-panel" class="card hidden collapsible-panel" style="margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">
            <div class="panel-header" style="margin-bottom: 10px;">
                <div class="panel-header-left">
                    <div style="font-weight: bold; color: #fff;">
                        ğŸ¤– å•äººå®æ—¶è¯­éŸ³AI
                        <span id="voice-ai-status" class="status status-disconnected" style="margin-left: 10px;">æœªè¿æ¥</span>
                    </div>
                    <button class="btn btn-secondary collapse-btn" onclick="toggleVoiceAICollapse()" title="æŠ˜å /å±•å¼€" id="voice-ai-collapse-btn">â–¼</button>
                </div>
                <div class="panel-header-right">
                    <button class="btn btn-primary" id="btn-voice-ai-start" onclick="startVoiceAI()">å¼€å§‹å¯¹è¯</button>
                    <button class="btn hidden" id="btn-voice-ai-mute" onclick="toggleVoiceAIMute()" style="background: #28a745; color: #fff;">ğŸ¤ å¼€éº¦</button>
                    <button class="btn btn-danger hidden" id="btn-voice-ai-stop" onclick="stopVoiceAI()">ç»“æŸå¯¹è¯</button>
                    <button class="btn btn-secondary" id="btn-voice-ai-save" onclick="saveVoiceAIChat()" style="display: none;">ğŸ’¾ ä¿å­˜è®°å½•</button>
                    <button class="btn btn-secondary" id="btn-voice-ai-clear" onclick="clearVoiceAIChat()" style="display: none;">ğŸ—‘ï¸ æ¸…ç©º</button>
                    <button class="btn btn-secondary expand-btn" onclick="toggleVoiceAIFullscreen()" title="å…¨å±å±•å¼€">â›¶</button>
                </div>
            </div>
            <div class="panel-content" id="voice-ai-panel-content">
            <div id="voice-ai-state-display" style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; display: none;">
                <span id="voice-ai-state-dot" style="display: inline-block; width: 12px; height: 12px; background: #888; border-radius: 50%; transition: all 0.3s;"></span>
                <span id="voice-ai-state-text" style="color: #fff; font-size: 14px;">ç©ºé—²</span>
            </div>

            <!-- èŠå¤©è®°å½•åŒºåŸŸ -->
            <div id="voice-ai-chat-area" style="max-height: 300px; overflow-y: auto; background: #1e3a1e; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 8px;">
                    <div style="display: flex; align-items: center;">
                        <div style="font-size: 13px; color: #aaa;">ğŸ’¬ å¯¹è¯è®°å½•</div>
                        <button class="btn btn-secondary copy-btn" onclick="copyVoiceAIChat()" title="å¤åˆ¶å¯¹è¯è®°å½•">ğŸ“‹ å¤åˆ¶</button>
                    </div>
                    <div style="font-size: 11px; color: #666;" id="voice-ai-chat-count">0 æ¡æ¶ˆæ¯</div>
                </div>
                <div id="voice-ai-chat-messages" style="display: flex; flex-direction: column; gap: 10px;">
                    <div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">å¼€å§‹å¯¹è¯åï¼ŒèŠå¤©è®°å½•å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
                </div>
            </div>

            <div id="voice-ai-transcript-area" style="max-height: 100px; overflow-y: auto; background: #2a2a2a; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: none;">
                <div style="font-size: 12px; color: #fff; margin-bottom: 5px;">ä½ è¯´çš„è¯</div>
                <div id="voice-ai-transcript-content" style="color: #fff; font-size: 14px;"></div>
            </div>
            <div id="voice-ai-response-area" style="max-height: 150px; overflow-y: auto; background: #2a2a2a; border-radius: 8px; padding: 10px; display: none;">
                <div style="font-size: 12px; color: #fff; margin-bottom: 5px;">AIå›å¤</div>
                <div id="voice-ai-response-content" style="color: #fff; font-size: 14px; line-height: 1.5;"></div>
            </div>
            <!-- ä¸Šä¸‹æ–‡æ–‡ä»¶ç®¡ç† -->
            <div id="voice-ai-context-files" style="margin-top: 10px;"></div>

            <div id="voice-ai-file-upload" style="margin-top: 15px; padding: 12px; background: #1a1a1a; border-radius: 8px; border: 2px dashed #4caf50;">
                <div style="font-size: 12px; color: #0f0; margin-bottom: 4px;">âœ“ æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å·²å¯ç”¨</div>

                <!-- æ–‡ä»¶ä¸Šä¼  -->
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 12px; color: #888; margin-bottom: 8px;">ğŸ“ é€‰æ‹©æ–‡ä»¶</div>
                    <input type="file" id="voice-ai-file-input" style="display: none;" onchange="handleVoiceAIFileSelect(event)" accept=".txt,.md,.js,.ts,.py,.json,.yaml,.yml,.xml,.html,.css">
                    <button class="btn btn-secondary" onclick="document.getElementById('voice-ai-file-input').click()" style="font-size: 12px; padding: 6px 12px;">é€‰æ‹©æ–‡ä»¶</button>
                    <span id="voice-ai-file-hint" style="font-size: 11px; color: #666; margin-left: 10px;">æ”¯æŒæ–‡æœ¬æ–‡ä»¶ (æœ€å¤§ 1MB)</span>
                </div>

                <!-- ç²˜è´´æ–‡æœ¬ -->
                <div style="border-top: 1px solid #333; padding-top: 12px;">
                    <div style="font-size: 12px; color: #888; margin-bottom: 8px;">ğŸ“ æˆ–ç²˜è´´æ–‡æœ¬å†…å®¹</div>
                    <textarea id="voice-ai-paste-text" placeholder="åœ¨æ­¤ç²˜è´´èŠå¤©è®°å½•æˆ–å…¶ä»–æ–‡æœ¬å†…å®¹..." style="width: 100%; min-height: 80px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; padding: 8px; color: #fff; font-size: 12px; resize: vertical; box-sizing: border-box;"></textarea>
                    <div style="margin-top: 8px;">
                        <button class="btn btn-secondary" onclick="addVoiceAIPastedText()" style="font-size: 12px; padding: 6px 12px;">æ·»åŠ æ–‡æœ¬</button>
                    </div>
                </div>
            </div>

            <div id="voice-ai-controls" style="display: none; margin-top: 10px;">
                <div style="color: #666; font-size: 12px;">
                    ğŸ’¡ ç‚¹å‡»"å¼€å§‹å¯¹è¯"åï¼Œç›´æ¥è¯´è¯å³å¯ä¸AIå¯¹è¯ã€‚AIä¼šè‡ªåŠ¨è¯†åˆ«è¯­éŸ³å¹¶å›å¤ã€‚
                </div>
            </div>
            <div id="voice-ai-error" style="color: #fff; font-size: 12px; margin-top: 10px; display: none;"></div>
            </div> <!-- voice-ai panel-content end -->
        </div>

        <!-- æ–‡ä»¶ä¸‹è½½æ  -->
        <div class="card">
            <h2>ğŸ“ æ–‡ä»¶ä¸‹è½½ä¸­å¿ƒ</h2>
            <div style="margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="refreshFileList()">ğŸ”„ åˆ·æ–°æ–‡ä»¶åˆ—è¡¨</button>
                <button class="btn btn-secondary" onclick="listAIFiles()">ğŸ¤– AIç”Ÿæˆæ–‡ä»¶</button>
                <button class="btn btn-secondary" onclick="listSharedFiles()">ğŸ“ å…±äº«æ–‡ä»¶</button>
                <button class="btn btn-secondary hidden" id="btn-manage-files" onclick="listSessionFilesForManage()">ğŸ”§ ç®¡ç†æ–‡ä»¶</button>
            </div>
            <div id="file-list-container" style="max-height: 300px; overflow-y: auto; background: #1a1a1a; border-radius: 8px; padding: 10px;">
                <div style="color: #fff; text-align: center; padding: 20px;">
                    ç‚¹å‡»"åˆ·æ–°æ–‡ä»¶åˆ—è¡¨"æŸ¥çœ‹å¯ä¸‹è½½çš„æ–‡ä»¶
                </div>
            </div>
        </div>

        <!-- è°ƒè¯•æ—¥å¿— -->
        <div class="card collapsible-panel collapsed" id="log-card">
            <div class="panel-header" style="margin-bottom: 0;">
                <div class="panel-header-left">
                    <h2 style="margin: 0;">è°ƒè¯•æ—¥å¿—</h2>
                    <button class="btn btn-secondary collapse-btn" onclick="toggleLogCollapse()" title="æŠ˜å /å±•å¼€" id="log-collapse-btn">â–¶</button>
                </div>
                <div class="panel-header-right">
                    <button class="btn btn-secondary" onclick="clearLog()" style="font-size: 12px; padding: 6px 12px;">æ¸…ç©ºæ—¥å¿—</button>
                </div>
            </div>
            <div class="panel-content" id="log-panel-content" style="margin-top: 10px;">
                <div class="log" id="log-container">
                    <div class="log-entry"><span class="log-time">[ç³»ç»Ÿ]</span> é¡µé¢å·²åŠ è½½ï¼Œç­‰å¾…è¿æ¥...</div>
                </div>
            </div>
        </div>

        <!-- é‚€è¯·äºŒç»´ç  -->
        <div class="card" id="invite-section">
            <h2>ğŸ“± é‚€è¯·å¥½å‹</h2>
            <div style="display: flex; justify-content: center; align-items: flex-start; gap: 20px; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div id="qrcode" style="margin-bottom: 8px;"></div>
                    <div style="font-size: 11px; color: #fff;">æ‰«ç åŠ å…¥èŠå¤©å®¤</div>
                </div>
                <div style="text-align: left;">
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 13px; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="include-password" style="vertical-align: middle;">
                            é‚€è¯·é“¾æ¥åŒ…å«å¯†ç 
                        </label>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="copyInviteLink()" style="font-size: 13px; padding: 8px 16px;">ğŸ“‹ å¤åˆ¶é“¾æ¥</button>
                        <button class="btn btn-secondary" onclick="downloadQRCode()" style="font-size: 13px; padding: 8px 16px;">ğŸ’¾ ä¿å­˜äºŒç»´ç </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let userId = localStorage.getItem('opencode-user-id') || ('user-' + Math.random().toString(36).substr(2, 9));
        localStorage.setItem('opencode-user-id', userId);
        let currentUser = null;
        let participants = new Map();

        // è¿æ¥çŠ¶æ€ç®¡ç†
        let isManualDisconnect = false;  // æ˜¯å¦ç”¨æˆ·ä¸»åŠ¨æ–­å¼€
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        let reconnectTimer = null;
        let lastConnectParams = null;  // ä¿å­˜è¿æ¥å‚æ•°ç”¨äºé‡è¿

        // Wake Lock ç®¡ç† - ä¿æŒå±å¹•å¸¸äº®
        let wakeLock = null;
        let wakeLockSupported = 'wakeLock' in navigator;

        async function requestWakeLock() {
            if (!wakeLockSupported) {
                log('Wake Lock ä¸æ”¯æŒæ­¤æµè§ˆå™¨');
                return false;
            }
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                log('å±å¹•å¸¸äº®å·²å¯ç”¨');
                wakeLock.addEventListener('release', () => {
                    log('å±å¹•å¸¸äº®å·²é‡Šæ”¾');
                });
                return true;
            } catch (err) {
                console.error('Wake Lock è¯·æ±‚å¤±è´¥:', err);
                log('å±å¹•å¸¸äº®å¯ç”¨å¤±è´¥: ' + err.message);
                return false;
            }
        }

        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    log('å±å¹•å¸¸äº®å·²å…³é—­');
                } catch (err) {
                    console.error('Wake Lock é‡Šæ”¾å¤±è´¥:', err);
                }
            }
        }

        // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶é‡æ–°è·å– Wake Lock
        async function handleWakeLockOnVisible() {
            if (document.visibilityState === 'visible' && (voiceChat.isJoined || sharedAI.isActive || voiceAI.isActive)) {
                if (!wakeLock) {
                    await requestWakeLock();
                }
            }
        }

        // èŠå¤©å®¤ç”¨æˆ·é¢œè‰²æ˜ å°„
        let chatUserColors = {};

        // èŠå¤©è®°å½•ç›¸å…³å˜é‡
        let chatHistory = [];
        let oldestMessageTime = null;
        let isLoadingHistory = false;
        let hasMoreHistory = true;
        let isUserScrollingUp = false;
        let autoScrollEnabled = true;  // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯åŠŸèƒ½ï¼Œé»˜è®¤å¼€å¯
        let initialHistoryLoaded = false;
        const HISTORY_LIMIT = 50;

        // ç¼“å­˜å¤§å°é™åˆ¶
        const MAX_VOICEAI_HISTORY = 100;       // è¯­éŸ³AIèŠå¤©è®°å½•æœ€å¤§æ¡æ•°
        const MAX_LOCALSTORAGE_SIZE = 4 * 1024 * 1024;  // localStorage æœ€å¤§ 4MBï¼ˆç•™1MBä½™é‡ï¼‰
        const MAX_CONTEXT_FILES = 10;          // ä¸Šä¸‹æ–‡æ–‡ä»¶æœ€å¤§æ•°é‡
        const MAX_CHAT_HISTORY = 500;          // èŠå¤©å®¤å†å²æ¶ˆæ¯æœ€å¤§æ¡æ•°
        const MAX_LOG_ENTRIES = 200;           // æ—¥å¿—æœ€å¤§æ¡æ•°

        // æ—¥å¿—åŠŸèƒ½
        function log(message, type = 'info') {
            const container = document.getElementById('log-container');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;

            // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
            while (container.children.length > MAX_LOG_ENTRIES) {
                container.removeChild(container.firstChild);
            }

            console.log(`[${time}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log-container').innerHTML = '';
        }

        // è¿æ¥æœåŠ¡å™¨
        let pendingPasswordQuestion = null;
        let pendingPasswordAnswer = null;

        // è§’è‰²å˜æ›´å¤„ç† - æ˜¾ç¤º/éšè—è§’è‰²å¯†ç è¾“å…¥æ¡†
        function onRoleChange() {
            const userRole = document.getElementById('user-role').value;
            const passwordGroup = document.getElementById('role-password-group');

            // å¦‚æœæ˜¯Owneræˆ–Adminï¼Œæ˜¾ç¤ºè§’è‰²å¯†ç è¾“å…¥æ¡†ï¼ˆåˆ›å»ºå¸¦å¯†ç æˆ¿é—´éœ€è¦ï¼‰
            if (userRole === 'owner' || userRole === 'admin') {
                passwordGroup.classList.remove('hidden');
            } else {
                passwordGroup.classList.add('hidden');
            }
        }

        // ç›‘å¬æˆ¿é—´å¯†ç è¾“å…¥å˜åŒ–
        document.getElementById('password-question').addEventListener('input', onRoleChange);
        document.getElementById('password-answer').addEventListener('input', onRoleChange);

        // è·å–é»˜è®¤ WebSocket åœ°å€ï¼ˆæ ¹æ®å½“å‰é¡µé¢åè®®è‡ªåŠ¨é€‰æ‹© ws/wssï¼‰
        function getDefaultWsUrl() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname;
            const wsPort = 3002; // WebSocket æœåŠ¡å™¨ç«¯å£
            return `${protocol}//${host}:${wsPort}`;
        }

        // è‡ªåŠ¨å¡«å……æœåŠ¡å™¨åœ°å€ï¼ˆå¦‚æœä¸ºç©ºï¼‰
        function autoFillServerUrl() {
            const serverUrlInput = document.getElementById('server-url');
            if (!serverUrlInput.value) {
                serverUrlInput.value = getDefaultWsUrl();
            }
        }

        function connect() {
            // è‡ªåŠ¨å¡«å……æœåŠ¡å™¨åœ°å€
            autoFillServerUrl();

            const serverUrl = document.getElementById('server-url').value;
            const sessionId = document.getElementById('session-id').value;
            const userName = document.getElementById('user-name').value;
            const userRole = document.getElementById('user-role').value;
            const authToken = document.getElementById('auth-token').value;

            // ä¿å­˜å¯†ç è®¾ç½®ï¼ˆå¦‚æœæ˜¯ Owner ä¸”è®¾ç½®äº†å¯†ç ï¼‰
            const passwordQuestionEl = document.getElementById('password-question');
            const passwordAnswerEl = document.getElementById('password-answer');
            const passwordQuestion = passwordQuestionEl ? passwordQuestionEl.value.trim() : '';
            const passwordAnswer = passwordAnswerEl ? passwordAnswerEl.value.trim() : '';


            // è§’è‰²å¯†ç éªŒè¯ï¼ˆOwnerå’ŒAdminéƒ½éœ€è¦ï¼‰
            const rolePasswordEl = document.getElementById('role-password');
            const rolePassword = rolePasswordEl ? rolePasswordEl.value.trim() : '';

            // åªè¦é€‰æ‹©Owneræˆ–Adminè§’è‰²ï¼Œå°±å¿…é¡»è¾“å…¥è§’è‰²å¯†ç 
            if (userRole === 'owner' || userRole === 'admin') {
                // æ£€æŸ¥è§’è‰²å¯†ç 
                if (!rolePassword) {
                    alert(`${userRole === 'owner' ? 'Owner' : 'Admin'}è§’è‰²éœ€è¦è¾“å…¥è§’è‰²å¯†ç æ‰èƒ½è¿æ¥`);
                    return;
                }

                // å¦‚æœè®¾ç½®äº†æˆ¿é—´å¯†ç ï¼Œä¿å­˜åˆ°pending
                if (passwordQuestion && passwordAnswer) {
                    pendingPasswordQuestion = passwordQuestion;
                    pendingPasswordAnswer = passwordAnswer;
                }
            } else {
                pendingPasswordQuestion = null;
                pendingPasswordAnswer = null;
            }

            if (!serverUrl || !sessionId || !userName) {
                alert('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«é¡¹');
                return;
            }

            // ä¿å­˜è¿æ¥å‚æ•°ç”¨äºé‡è¿
            lastConnectParams = { serverUrl, sessionId, userName, userRole, authToken, rolePassword, passwordQuestion, passwordAnswer };
            isManualDisconnect = false;

            currentUser = { id: userId, name: userName, role: userRole };

            let wsUrl = serverUrl;
            if (authToken) {
                wsUrl += `?token=${encodeURIComponent(authToken)}`;
            } else {
                wsUrl += `?session=${encodeURIComponent(sessionId)}`;
                wsUrl += `&name=${encodeURIComponent(userName)}`;
                wsUrl += `&role=${encodeURIComponent(userRole)}`;
                // å¦‚æœæ˜¯ Owner æˆ– Adminï¼Œé€šè¿‡ URL å‚æ•°ä¼ é€’è§’è‰²å¯†ç å’Œæˆ¿é—´å¯†ç ï¼ˆå¦‚æœè®¾ç½®äº†ï¼‰
                if (userRole === 'owner' || userRole === 'admin') {
                    // å¿…é¡»ä¼ é€’è§’è‰²å¯†ç 
                    wsUrl += `&role_password=${encodeURIComponent(rolePassword)}`;

                    // å¦‚æœè®¾ç½®äº†æˆ¿é—´å¯†ç ï¼Œä¹Ÿä¼ é€’
                    if (passwordQuestion && passwordAnswer) {
                        wsUrl += `&pwd_question=${encodeURIComponent(passwordQuestion)}`;
                        wsUrl += `&pwd_answer=${encodeURIComponent(passwordAnswer)}`;
                        log(`[å‰ç«¯] ${userRole} è¿æ¥ï¼Œæºå¸¦æˆ¿é—´å¯†ç å‚æ•°`);
                    } else {
                        log(`[å‰ç«¯] ${userRole} è¿æ¥ï¼Œæºå¸¦è§’è‰²å¯†ç `);
                    }
                }
                // å¦‚æœæ˜¯é€šè¿‡é‚€è¯·é“¾æ¥è®¿é—®ä¸”åŒ…å«å¯†ç ç­”æ¡ˆï¼Œä¼ é€’å¯†ç 
                else if (pendingPasswordAnswer) {
                    wsUrl += `&pwd_answer=${encodeURIComponent(pendingPasswordAnswer)}`;
                    log(`[å‰ç«¯] ä½¿ç”¨é‚€è¯·é“¾æ¥å¯†ç è¿æ¥`);
                }
            }

            log(`æ­£åœ¨è¿æ¥: ${serverUrl}`);
            updateStatus('connecting', 'è¿æ¥ä¸­...');

            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('WebSocket è¿æ¥å·²å»ºç«‹');
                    reconnectAttempts = 0;  // é‡ç½®é‡è¿è®¡æ•°
                    // ç­‰å¾…æœåŠ¡å™¨å‘é€ connection.established åå†æ˜¾ç¤ºèŠå¤©ç•Œé¢
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        // å‡å°‘é¢‘ç¹æ¶ˆæ¯çš„æ—¥å¿—è¾“å‡º
                        const silentTypes = ['voice.audio', 'voice.transcript', 'voice.transcript.final',
                            'shared_ai.audio', 'shared_ai.user_audio', 'shared_ai.state', 'shared_ai.response', 'shared_ai.asr',
                            'voice_ai.audio', 'voice_ai.transcript', 'voice_ai.state'];
                        if (!silentTypes.includes(data.type)) {
                            log(`æ”¶åˆ°æ¶ˆæ¯: ${data.type}`);
                        }
                        handleServerMessage(data);
                    } catch (e) {
                        log(`æ”¶åˆ°åŸå§‹æ¶ˆæ¯: ${event.data}`);
                    }
                };

                ws.onclose = (event) => {
                    log(`è¿æ¥å·²å…³é—­: ${event.code} - ${event.reason}`);

                    // æ¸…ç†è¯­éŸ³èŠå¤©
                    if (voiceChat.isJoined) {
                        leaveVoiceChat();
                    }
                    // æ¸…ç†è¯­éŸ³AI
                    if (voiceAI.isActive) {
                        stopVoiceAI();
                    }

                    // å¦‚æœä¸æ˜¯ç”¨æˆ·ä¸»åŠ¨æ–­å¼€ï¼Œå°è¯•é‡è¿
                    if (!isManualDisconnect && lastConnectParams && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const delay = Math.min(1000 * reconnectAttempts, 5000);  // é€’å¢å»¶è¿Ÿï¼Œæœ€å¤§5ç§’
                        log(`å°†åœ¨ ${delay/1000} ç§’åå°è¯•é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                        updateStatus('connecting', `é‡è¿ä¸­ ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);

                        reconnectTimer = setTimeout(() => {
                            if (!isManualDisconnect && lastConnectParams) {
                                reconnect();
                            }
                        }, delay);
                    } else if (!isManualDisconnect) {
                        // é‡è¿æ¬¡æ•°ç”¨å°½
                        updateStatus('disconnected', 'è¿æ¥å·²æ–­å¼€');
                        hideChat();
                        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                            alert('è¿æ¥å·²æ–­å¼€ï¼Œé‡è¿å¤±è´¥ã€‚è¯·æ‰‹åŠ¨é‡æ–°è¿æ¥ã€‚');
                        }
                    } else {
                        updateStatus('disconnected', 'æœªè¿æ¥');
                        hideChat();
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    let errorMsg = 'è¿æ¥å¤±è´¥';
                    if (serverUrl.startsWith('wss://')) {
                        errorMsg += ' - å¦‚æœæ˜¯è‡ªç­¾åè¯ä¹¦ï¼Œè¯·å…ˆåœ¨æµè§ˆå™¨ä¸­è®¿é—® https://' + serverUrl.split('/')[2] + ' å¹¶æ¥å—è¯ä¹¦';
                    }
                    log('WebSocket é”™è¯¯: ' + (error.message || errorMsg));
                    // ä¸å¼¹å‡ºalertï¼Œè®©oncloseå¤„ç†é‡è¿
                };

            } catch (error) {
                log('è¿æ¥å¤±è´¥: ' + error.message);
                updateStatus('disconnected', 'è¿æ¥å¤±è´¥');
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            isManualDisconnect = true;  // æ ‡è®°ä¸ºç”¨æˆ·ä¸»åŠ¨æ–­å¼€
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            reconnectAttempts = 0;
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // é‡è¿å‡½æ•°
        function reconnect() {
            if (!lastConnectParams) return;

            const { serverUrl, sessionId, userName, userRole, authToken, rolePassword, passwordQuestion, passwordAnswer } = lastConnectParams;

            currentUser = { id: userId, name: userName, role: userRole };

            let wsUrl = serverUrl;
            if (authToken) {
                wsUrl += `?token=${encodeURIComponent(authToken)}`;
            } else {
                wsUrl += `?session=${encodeURIComponent(sessionId)}`;
                wsUrl += `&name=${encodeURIComponent(userName)}`;
                wsUrl += `&role=${encodeURIComponent(userRole)}`;
                if (userRole === 'owner' || userRole === 'admin') {
                    wsUrl += `&role_password=${encodeURIComponent(rolePassword)}`;
                    if (passwordQuestion && passwordAnswer) {
                        wsUrl += `&pwd_question=${encodeURIComponent(passwordQuestion)}`;
                        wsUrl += `&pwd_answer=${encodeURIComponent(passwordAnswer)}`;
                    }
                } else if (pendingPasswordAnswer) {
                    wsUrl += `&pwd_answer=${encodeURIComponent(pendingPasswordAnswer)}`;
                }
            }

            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('é‡è¿æˆåŠŸ');
                    reconnectAttempts = 0;
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        const silentTypes = ['voice.audio', 'voice.transcript', 'voice.transcript.final',
                            'shared_ai.audio', 'shared_ai.user_audio', 'shared_ai.state', 'shared_ai.response', 'shared_ai.asr',
                            'voice_ai.audio', 'voice_ai.transcript', 'voice_ai.state'];
                        if (!silentTypes.includes(data.type)) {
                            log(`æ”¶åˆ°æ¶ˆæ¯: ${data.type}`);
                        }
                        handleServerMessage(data);
                    } catch (e) {
                        log(`æ”¶åˆ°åŸå§‹æ¶ˆæ¯: ${event.data}`);
                    }
                };

                ws.onclose = (event) => {
                    log(`è¿æ¥å·²å…³é—­: ${event.code} - ${event.reason}`);
                    if (voiceChat.isJoined) leaveVoiceChat();
                    if (voiceAI.isActive) stopVoiceAI();

                    if (!isManualDisconnect && lastConnectParams && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const delay = Math.min(1000 * reconnectAttempts, 5000);
                        log(`å°†åœ¨ ${delay/1000} ç§’åå°è¯•é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                        updateStatus('connecting', `é‡è¿ä¸­ ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}...`);

                        reconnectTimer = setTimeout(() => {
                            if (!isManualDisconnect && lastConnectParams) {
                                reconnect();
                            }
                        }, delay);
                    } else if (!isManualDisconnect) {
                        updateStatus('disconnected', 'è¿æ¥å·²æ–­å¼€');
                        hideChat();
                    } else {
                        updateStatus('disconnected', 'æœªè¿æ¥');
                        hideChat();
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    log('WebSocket é”™è¯¯');
                };

            } catch (error) {
                log('é‡è¿å¤±è´¥: ' + error.message);
            }
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateStatus(status, text) {
            const statusEl = document.getElementById('connection-status');
            statusEl.className = `status status-${status}`;
            statusEl.textContent = text;

            if (status === 'connected') {
                document.getElementById('disconnect-btn').classList.remove('hidden');
            } else {
                document.getElementById('disconnect-btn').classList.add('hidden');
            }
        }

        // æ˜¾ç¤º/éšè—èŠå¤©ç•Œé¢
        function showChat() {
            document.getElementById('config-card').classList.add('hidden');
            document.getElementById('password-card').classList.add('hidden');
            document.getElementById('chat-card').classList.remove('hidden');
            document.getElementById('voice-ai-panel').classList.remove('hidden');
            document.getElementById('shared-ai-panel').classList.remove('hidden');

            // é»˜è®¤å±•å¼€èŠå¤©å®¤ï¼ŒæŠ˜å ä¸¤ä¸ªè¯­éŸ³é¢æ¿
            document.getElementById('shared-ai-panel').classList.add('collapsed');
            document.getElementById('shared-ai-collapse-btn').textContent = 'â–¶';
            document.getElementById('voice-ai-panel').classList.add('collapsed');
            document.getElementById('voice-ai-collapse-btn').textContent = 'â–¶';

            // åŠ è½½å…±äº«AIä¸Šä¸‹æ–‡æ–‡ä»¶
            loadSharedAIContextFiles();

            // é¡µé¢æ»šåŠ¨åˆ°é¡¶éƒ¨
            window.scrollTo(0, 0);

            // ç”Ÿæˆé‚€è¯·äºŒç»´ç 
            setTimeout(generateQRCode, 100);
        }

        function hideChat() {
            document.getElementById('config-card').classList.remove('hidden');
            document.getElementById('password-card').classList.add('hidden');
            document.getElementById('chat-card').classList.add('hidden');
            document.getElementById('voice-ai-panel').classList.add('hidden');
            document.getElementById('shared-ai-panel').classList.add('hidden');
        }

        // æ˜¾ç¤ºå¯†ç éªŒè¯ç•Œé¢
        function showPasswordCard(question) {
            document.getElementById('config-card').classList.add('hidden');
            document.getElementById('chat-card').classList.add('hidden');
            document.getElementById('voice-ai-panel').classList.add('hidden');
            document.getElementById('shared-ai-panel').classList.add('hidden');
            document.getElementById('password-card').classList.remove('hidden');
            document.getElementById('password-question-display').textContent = question || 'è¯·è¾“å…¥å¯†ç ';
            document.getElementById('password-answer-input').value = '';
            document.getElementById('password-answer-input').focus();
            log('éœ€è¦å¯†ç éªŒè¯æ‰èƒ½è¿›å…¥èŠå¤©å®¤');
        }

        // éšè—å¯†ç éªŒè¯ç•Œé¢
        function hidePasswordCard() {
            document.getElementById('password-card').classList.add('hidden');
        }

        // æäº¤å¯†ç ç­”æ¡ˆ
        function submitPassword() {
            const answer = document.getElementById('password-answer-input').value.trim();
            if (!answer) {
                alert('è¯·è¾“å…¥å¯†ç ç­”æ¡ˆ');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¿æ¥å·²æ–­å¼€ï¼Œè¯·é‡æ–°è¿æ¥');
                return;
            }

            const message = {
                type: 'verify_password',
                answer: answer
            };

            ws.send(JSON.stringify(message));
            log('å‘é€å¯†ç ç­”æ¡ˆ');
        }

        // åŠ è½½åˆå§‹å†å²è®°å½•ï¼ˆæœ€æ–°çš„æ¶ˆæ¯ï¼‰
        function loadInitialHistory() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            // ä¸è®¾ç½® before å‚æ•°ï¼Œè·å–æœ€æ–°çš„æ¶ˆæ¯
            const message = {
                type: 'get_history',
                limit: HISTORY_LIMIT
                // ä¸è®¾ç½® beforeï¼Œè·å–æœ€æ–°æ¶ˆæ¯
            };

            ws.send(JSON.stringify(message));
            log('è¯·æ±‚åŠ è½½å†å²æ¶ˆæ¯');
            isLoadingHistory = true;
            updateLoadMoreButton();
        }

        // åŠ è½½æ›´å¤šå†å²è®°å½•
        function loadMoreHistory() {
            if (!ws || ws.readyState !== WebSocket.OPEN || isLoadingHistory || !hasMoreHistory) return;

            const message = {
                type: 'get_history',
                limit: HISTORY_LIMIT,
                before: oldestMessageTime
            };

            ws.send(JSON.stringify(message));
            log('è¯·æ±‚åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯');
            isLoadingHistory = true;
            updateLoadMoreButton();
        }

        // æ›´æ–°åŠ è½½æŒ‰é’®çŠ¶æ€
        function updateLoadMoreButton() {
            const container = document.getElementById('load-more-container');
            const btn = document.getElementById('load-more-btn');

            if (!hasMoreHistory) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            if (isLoadingHistory) {
                btn.disabled = true;
                btn.innerHTML = '<span class="loading-spinner"></span>åŠ è½½ä¸­...';
            } else {
                btn.disabled = false;
                btn.innerHTML = 'åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯';
            }
        }

        // å¤„ç†å†å²è®°å½•åŠ è½½å®Œæˆ
        function handleHistoryLoaded(data) {
            isLoadingHistory = false;

            const messages = data.payload?.messages || [];

            log(`æ”¶åˆ° ${messages.length} æ¡å†å²æ¶ˆæ¯`);

            if (messages.length === 0) {
                hasMoreHistory = false;
                updateLoadMoreButton();
                initialHistoryLoaded = true;
                return;
            }

            // æ›´æ–°æœ€æ—©æ¶ˆæ¯æ—¶é—´
            oldestMessageTime = messages[messages.length - 1].timestamp;

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šå†å²è®°å½•
            hasMoreHistory = messages.length >= HISTORY_LIMIT;
            updateLoadMoreButton();

            // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
            const container = document.getElementById('chat-container');
            const oldScrollHeight = container.scrollHeight;
            const oldScrollTop = container.scrollTop;

            // å°†æ–°åŠ è½½çš„æ¶ˆæ¯æ·»åŠ åˆ°å†å²æ•°ç»„å¼€å¤´
            // æ˜ å°„å­—æ®µåç§°ï¼ˆæ•°æ®åº“ä½¿ç”¨ä¸‹åˆ’çº¿ï¼Œå‰ç«¯ä½¿ç”¨é©¼å³°ï¼‰
            const mappedMessages = messages.map(msg => ({
                ...msg,
                senderId: msg.senderId || msg.sender_id,
                senderName: msg.senderName || msg.sender_name,
                senderRole: msg.senderRole || msg.sender_role,
            }));
            chatHistory = [...mappedMessages, ...chatHistory];

            // å¦‚æœæ˜¯åˆå§‹åŠ è½½ï¼Œæ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“
            if (!initialHistoryLoaded) {
                const loadMoreContainer = document.getElementById('load-more-container');
                container.innerHTML = '';
                container.appendChild(loadMoreContainer);

                // æ¸…ç©ºä¾§è¾¹æ 
                document.getElementById('mentions-list').innerHTML = '<div class="sidebar-empty">æš‚æ— @æåŠæ¶ˆæ¯</div>';
                document.getElementById('ai-responses-list').innerHTML = '<div class="sidebar-empty">æš‚æ— AIå›å¤</div>';

                // æ”¶é›†éœ€è¦æ·»åŠ åˆ°ä¾§è¾¹æ çš„æ¶ˆæ¯
                const sidebarMessages = [];

                // æŒ‰æ—¶é—´æ­£åºæ¸²æŸ“æ‰€æœ‰æ¶ˆæ¯ï¼ˆå€’åºéå†ï¼Œè®©æœ€æ—©çš„æ¶ˆæ¯åœ¨æœ€ä¸Šé¢ï¼‰
                for (let i = messages.length - 1; i >= 0; i--) {
                    const msg = messages[i];
                    const isOwn = msg.senderId === userId || msg.sender_id === userId;
                    prependMessage(msg, isOwn);
                    // æ”¶é›†ä¾§è¾¹æ æ¶ˆæ¯
                    if (shouldAddToSidebar(msg)) {
                        sidebarMessages.push(msg);
                    }
                }

                // æŒ‰æ—¶é—´å€’åºæ·»åŠ åˆ°ä¾§è¾¹æ ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
                sidebarMessages.reverse().forEach(msg => addToSidebar(msg, true));

                container.scrollTop = container.scrollHeight;
                initialHistoryLoaded = true;
            } else {
                // åŠ è½½æ›´å¤šï¼šåœ¨é¡¶éƒ¨æ’å…¥æ¶ˆæ¯ï¼ˆå€’åºéå†ï¼Œè®©æœ€æ—©çš„æ¶ˆæ¯åœ¨æœ€ä¸Šé¢ï¼‰
                const sidebarMessages = [];
                for (let i = mappedMessages.length - 1; i >= 0; i--) {
                    const msg = mappedMessages[i];
                    const isOwn = msg.senderId === userId;
                    prependMessage(msg, isOwn);
                    if (shouldAddToSidebar(msg)) {
                        sidebarMessages.push(msg);
                    }
                }
                // æŒ‰æ—¶é—´å€’åºæ·»åŠ 
                sidebarMessages.reverse().forEach(msg => addToSidebar(msg, true));

                // ä¿æŒæ»šåŠ¨ä½ç½®
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
            }
        }

        // åœ¨æ¶ˆæ¯åˆ—è¡¨é¡¶éƒ¨æ’å…¥æ¶ˆæ¯
        function prependMessage(message, isOwn) {
            const container = document.getElementById('chat-container');
            const loadMoreContainer = document.getElementById('load-more-container');

            const div = document.createElement('div');

            const isAIMessage = message.senderRole === 'ai' || message.senderId === 'ai-assistant';

            if (isAIMessage) {
                div.className = 'message message-ai';
            } else {
                div.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
            }

            if (message.id) {
                div.setAttribute('data-message-id', message.id);
            }

            let contentHtml = highlightMentions(message.content || '');

            if (message.type === 'file' && message.fileData) {
                const fileData = message.fileData;
                const fileIcon = getFileIcon(fileData.mimeType || '');
                const fileSize = formatFileSize(fileData.fileSize || 0);


                if (message.id) {
                    div.setAttribute('data-file-id', message.id);
                }
                if (fileData.ossUrl) {
                    div.setAttribute('data-oss-url', fileData.ossUrl);
                }
                if (fileData.ossKey) {
                    div.setAttribute('data-oss-key', fileData.ossKey);
                }

                // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé€šè¿‡ data å±æ€§å­˜å‚¨æ•°æ®
                const downloadBtnId = 'dl-btn-' + message.id;
                if (fileData.ossUrl) {
                    pendingFileDownloads.set(downloadBtnId, {
                        url: fileData.ossUrl,
                        filename: fileData.fileName || 'download',
                        ossKey: fileData.ossKey || ''
                    });
                }

                contentHtml = `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #333; border-radius: 8px; margin-top: 5px;">
                        <span style="font-size: 24px;">${fileIcon}</span>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${fileData.fileName || 'æœªçŸ¥æ–‡ä»¶'}</div>
                            <div style="font-size: 12px; color: #fff;">${fileSize}</div>
                        </div>
                        ${fileData.ossUrl
                            ? `<button id="${downloadBtnId}" class="file-download-btn" style="color: #fff; background: #2a2a2a; border: none; padding: 5px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;">ä¸‹è½½</button>`
                            : '<span style="font-size: 12px; color: #fff;">ä¸Šä¼ ä¸­...</span>'}
                    </div>
                `;
            } else if (isAIMessage) {
                const fullContent = markdownToHtml(message.content || '');
                const plainText = message.content || '';
                const previewText = plainText.substring(0, 20);
                const needsExpansion = plainText.length > 20;

                if (needsExpansion) {
                    contentHtml = `
                        <div class="ai-content-collapsed" data-ai-content="${message.id}">
                            <span class="ai-content-preview">${previewText}</span>
                            <span class="ai-expand-btn" data-ai-btn="${message.id}" onclick="toggleAIContent('${message.id}')">[å±•å¼€]</span>
                            <div class="ai-content-full">${fullContent}</div>
                        </div>
                    `;
                } else {
                    contentHtml = fullContent;
                }
            }

            if (message.type === 'image' && message.imageData) {
                const imgUrl = message.imageData.url || message.imageData.ossUrl;
                if (imgUrl) {
                    contentHtml = `<img src="${imgUrl}" style="max-width: 100%; border-radius: 8px; margin-top: 5px;" />`;
                }
            }

            const senderName = message.senderName || message.userName || 'æœªçŸ¥ç”¨æˆ·';
            const timestamp = message.timestamp ? new Date(message.timestamp).toLocaleString() : new Date().toLocaleString();

            div.innerHTML = `
                <div class="message-header">${senderName} Â· ${timestamp}</div>
                <div class="message-content">${contentHtml}</div>
            `;

            container.insertBefore(div, loadMoreContainer.nextSibling);
        }

        // ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼Œæ£€æµ‹æ˜¯å¦æ»šåŠ¨åˆ°é¡¶éƒ¨
        function setupScrollListener() {
            const container = document.getElementById('chat-container');

            container.addEventListener('scroll', () => {
                const scrollTop = container.scrollTop;
                const scrollHeight = container.scrollHeight;
                const clientHeight = container.clientHeight;

                // æ£€æµ‹ç”¨æˆ·æ˜¯å¦æ»šåŠ¨åˆ°é¡¶éƒ¨é™„è¿‘
                if (scrollTop < 50 && hasMoreHistory && !isLoadingHistory && initialHistoryLoaded) {
                    loadMoreHistory();
                }

                // æ£€æµ‹ç”¨æˆ·æ˜¯å¦æ­£åœ¨å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹å†å²
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 50;
                isUserScrollingUp = !isAtBottom;
            });
        }

        setupScrollListener();

        // å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
        function handleServerMessage(data) {
            switch (data.type) {
                case 'connection.established':
                    updateStatus('connected', 'å·²è¿æ¥');
                    showChat();
                    log('æœåŠ¡å™¨ç¡®è®¤è¿æ¥æˆåŠŸ');
                    document.getElementById('room-name').textContent = `(${data.payload?.sessionId || ''})`;

                    // å¦‚æœæ˜¯adminæˆ–ownerï¼Œæ˜¾ç¤ºæ–‡ä»¶ç®¡ç†æŒ‰é’®
                    const userRole = document.getElementById('user-role').value;
                    if (userRole === 'admin' || userRole === 'owner') {
                        document.getElementById('btn-manage-files').classList.remove('hidden');
                    }

                    // é‡ç½®å†å²è®°å½•çŠ¶æ€
                    chatHistory = [];
                    oldestMessageTime = null;
                    hasMoreHistory = true;
                    initialHistoryLoaded = false;
                    // æ¸…ç©ºèŠå¤©å®¹å™¨
                    document.getElementById('chat-container').innerHTML = `
                        <div class="load-more-container" id="load-more-container" style="display: none;">
                            <button class="load-more-btn" id="load-more-btn" onclick="loadMoreHistory()">
                                åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
                            </button>
                        </div>
                    `;
                    // åŠ è½½æœ€è¿‘ä¸€å¤©çš„å†å²æ¶ˆæ¯
                    loadInitialHistory();

                    // å¯†ç å·²é€šè¿‡ URL å‚æ•°è®¾ç½®ï¼Œæ— éœ€å†å‘é€ set_password æ¶ˆæ¯
                    // ä¿ç•™ pendingPasswordQuestion å’Œ pendingPasswordAnswer ç”¨äºç”Ÿæˆé‚€è¯·é“¾æ¥

                    sendSystemMessage(`${document.getElementById('user-name').value} åŠ å…¥äº†ä¼šè¯`);
                    break;
                case 'password.set':
                    addSystemMessage('å¯†ç è®¾ç½®æˆåŠŸ');
                    log('å¯†ç è®¾ç½®æˆåŠŸ');
                    break;
                case 'message':
                case 'message.new':
                case 'ai.response':
                    const msg = data.payload || data.message;
                    if (msg) {
                        msg.senderName = data.senderName || msg.senderName || msg.sender_name || 'æœªçŸ¥ç”¨æˆ·';
                        msg.senderId = data.senderId || msg.senderId || msg.sender_id;
                        msg.senderRole = data.senderRole || msg.senderRole || msg.sender_role || 'member';
                        msg.timestamp = msg.timestamp || data.timestamp || new Date().toISOString();

                        if (msg.type === 'file' && msg.fileData) {
                            log(`æ”¶åˆ°æ–‡ä»¶æ¶ˆæ¯: ${msg.fileData.fileName || 'æœªçŸ¥æ–‡ä»¶'}`);
                        }

                        chatHistory.push(msg);

                        // é™åˆ¶èŠå¤©å†å²å¤§å°ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
                        if (chatHistory.length > MAX_CHAT_HISTORY) {
                            chatHistory = chatHistory.slice(-MAX_CHAT_HISTORY);
                        }

                        const shouldScroll = autoScrollEnabled && !isUserScrollingUp;
                        addMessage(msg, data.senderId === userId, shouldScroll);

                        log(`æ”¶åˆ°æ¶ˆæ¯: ${msg.content?.substring(0, 30)}...`);
                    } else {
                        log('æ”¶åˆ°æ¶ˆæ¯ä½†æ ¼å¼ä¸æ­£ç¡®: ' + JSON.stringify(data));
                    }
                    break;
                case 'user.joined':
                    const joinedUser = data.payload || data.user;
                    if (joinedUser) {
                        addSystemMessage(`${joinedUser.userName || joinedUser.name} åŠ å…¥äº†ä¼šè¯`);
                        addParticipant(joinedUser);
                    }
                    break;
                case 'user.left':
                    const leftUser = data.payload || data.user;
                    if (leftUser) {
                        addSystemMessage(`${leftUser.userName || leftUser.name || 'ç”¨æˆ·'} ç¦»å¼€äº†ä¼šè¯`);
                        removeParticipant(leftUser.userId || leftUser.id);
                    }
                    break;
                case 'typing.start':
                    log(`${data.senderName || 'æŸäºº'} æ­£åœ¨è¾“å…¥...`);
                    break;
                case 'summary.generating':
                    addSystemMessage('æ­£åœ¨ç”Ÿæˆå¯¹è¯æ€»ç»“...');
                    log('ç”Ÿæˆæ€»ç»“ä¸­...');
                    break;
                case 'summary.completed':
                    const summary = data.payload?.summary || '';
                    displaySummary(summary);
                    addSystemMessage(`å¯¹è¯æ€»ç»“å·²ç”Ÿæˆï¼ˆåŸºäº ${data.payload?.messageCount || 0} æ¡æ¶ˆæ¯ï¼‰`);
                    log('æ€»ç»“ç”Ÿæˆå®Œæˆ');
                    break;
                case 'summary.error':
                    addSystemMessage(`æ€»ç»“ç”Ÿæˆå¤±è´¥: ${data.payload?.error || 'æœªçŸ¥é”™è¯¯'}`);
                    log('æ€»ç»“ç”Ÿæˆå¤±è´¥: ' + (data.payload?.error || 'æœªçŸ¥é”™è¯¯'));
                    break;
                case 'ai.memory_cleared':
                    hideSummary();
                    addSystemMessage(`${data.payload?.message || 'AIè®°å¿†å·²æ¸…ç©º'}`);
                    log('AIè®°å¿†å·²æ¸…ç©º');
                    break;
                // AI ä»»åŠ¡è®¡åˆ’æ¶ˆæ¯å¤„ç†
                case 'ai.task_plan':
                    handleAITaskPlan(data.payload);
                    break;
                case 'ai.task_update':
                    handleAITaskUpdate(data.payload);
                    break;
                case 'history.loaded':
                    handleHistoryLoaded(data);
                    break;
                case 'password.required':
                    showPasswordCard(data.payload?.question);
                    break;
                case 'password.incorrect':
                    alert('å¯†ç ç­”æ¡ˆä¸æ­£ç¡®ï¼Œè¯·é‡è¯•');
                    log('å¯†ç ç­”æ¡ˆä¸æ­£ç¡®');
                    break;
                // è¯­éŸ³èŠå¤©æ¶ˆæ¯å¤„ç†
                case 'voice.join':
                case 'voice.leave':
                case 'voice.start_speaking':
                case 'voice.stop_speaking':
                case 'voice.transcript':
                case 'voice.transcript.final':
                case 'voice.ai_analyze':
                case 'voice.error':
                case 'voice.status':
                case 'voice.asr_ready':
                case 'voice.audio':
                    handleVoiceMessage(data);
                    break;
                // è¯­éŸ³AIæ¶ˆæ¯å¤„ç†
                case 'voice_ai.started':
                case 'voice_ai.stopped':
                case 'voice_ai.error':
                case 'voice_ai.asr':
                case 'voice_ai.response':
                case 'voice_ai.audio':
                case 'voice_ai.state':
                    handleVoiceAIMessage(data);
                    break;
                // å…±äº«è¯­éŸ³AIæ¶ˆæ¯å¤„ç†
                case 'shared_ai.started':
                case 'shared_ai.stopped':
                case 'shared_ai.joined':
                case 'shared_ai.left':
                case 'shared_ai.error':
                case 'shared_ai.asr':
                case 'shared_ai.response':
                case 'shared_ai.audio':
                case 'shared_ai.state':
                case 'shared_ai.context_added':
                case 'shared_ai.user_joined':
                case 'shared_ai.user_left':
                case 'shared_ai.user_audio':
                    handleSharedAIMessage(data);
                    break;
                // æ–‡ä»¶ä¸‹è½½URLåˆ·æ–°
                case 'download_url_refreshed':
                    handleDownloadUrlRefreshed(data);
                    break;
                case 'download_url_error':
                    log(`ä¸‹è½½URLåˆ·æ–°å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
                    addSystemMessage(`æ–‡ä»¶ä¸‹è½½å¤±è´¥: ${data.error || 'æ— æ³•è·å–ä¸‹è½½é“¾æ¥'}`, 'error');
                    break;
                // æ–‡ä»¶ç®¡ç†æ¶ˆæ¯
                case 'session_files_list':
                    displayManageFileList(data.payload?.files || []);
                    break;
                case 'file.deleted':
                    log(`æ–‡ä»¶å·²åˆ é™¤: ${data.payload?.fileName || 'æœªçŸ¥æ–‡ä»¶'}`);
                    addSystemMessage(`æ–‡ä»¶ "${data.payload?.fileName || 'æœªçŸ¥æ–‡ä»¶'}" å·²è¢« ${data.payload?.deletedByRole || 'ç®¡ç†å‘˜'} åˆ é™¤`, 'success');
                    // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                    if (document.getElementById('btn-manage-files') && !document.getElementById('btn-manage-files').classList.contains('hidden')) {
                        listSessionFilesForManage();
                    }
                    break;
                case 'file.renamed':
                    log(`æ–‡ä»¶å·²é‡å‘½å: ${data.payload?.oldFileName} -> ${data.payload?.newFileName}`);
                    addSystemMessage(`æ–‡ä»¶ "${data.payload?.oldFileName}" å·²è¢« ${data.payload?.renamedByRole || 'ç®¡ç†å‘˜'} é‡å‘½åä¸º "${data.payload?.newFileName}"`, 'success');
                    // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                    if (document.getElementById('btn-manage-files') && !document.getElementById('btn-manage-files').classList.contains('hidden')) {
                        listSessionFilesForManage();
                    }
                    break;
                case 'error':
                    const errorMsg = data.payload?.message || data.message || 'æœªçŸ¥é”™è¯¯';
                    addSystemMessage(`é”™è¯¯: ${errorMsg}`, 'error');
                    log(`æœåŠ¡å™¨é”™è¯¯: ${errorMsg}`);
                    break;
                // @AI æŒ‰é’® ASR ç»“æœ
                case 'ai_button_asr.result':
                    handleAIButtonASRResult(data);
                    break;
                // èŠå¤©å®¤è¯­éŸ³AIæ¶ˆæ¯
                case 'chat_voice_ai.started':
                case 'chat_voice_ai.stopped':
                case 'chat_voice_ai.state':
                case 'chat_voice_ai.asr':
                case 'chat_voice_ai.response':
                case 'chat_voice_ai.audio':
                case 'chat_voice_ai.error':
                case 'chat_voice_ai.mode_changed':
                    handleChatVoiceAIMessage(data);
                    break;
                default:
                    log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${data.type}`);
            }
        }

        // å‘é€æ¶ˆæ¯
        function sendMessage() {
            const input = document.getElementById('message-input');
            const content = input.value.trim();

            if (!content || !ws) return;

            const mentions = [];
            let mentionsAI = false;
            if (content.includes('@ai')) {
                mentions.push('ai');
                mentionsAI = true;
            }
            if (content.includes('@all')) {
                mentions.push('all');
            }

            const message = {
                type: 'message',
                message: {
                    id: 'msg-' + Date.now(),
                    type: 'text',
                    content: content,
                    mentions: mentions,
                    mentionsAI: mentionsAI
                }
            };

            ws.send(JSON.stringify(message));
            input.value = '';
            log(`å‘é€æ¶ˆæ¯: ${content}`);
        }

        // å‘é€æåŠ
        function sendMention(mention) {
            const input = document.getElementById('message-input');
            input.value = mention + ' ' + input.value;
            input.focus();
        }

        // ===========================================================================
        // @AI æŒ‰é’®é•¿æŒ‰è¯­éŸ³è¯†åˆ«åŠŸèƒ½ï¼ˆä½¿ç”¨æœåŠ¡ç«¯é˜¿é‡Œäº‘ ASRï¼‰
        // ===========================================================================

        let aiButtonASR = {
            isActive: false,
            longPressTimer: null,
            accumulatedText: '',
            isLongPress: false,
            longPressThreshold: 300, // é•¿æŒ‰é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
            // éŸ³é¢‘å½•åˆ¶ç›¸å…³
            mediaStream: null,
            audioContext: null,
            audioProcessor: null,
        };

        // æ›´æ–°æŒ‰é’®æ ·å¼
        function updateAIButtonStyle(isActive) {
            const btn = document.getElementById('btn-ai-mention');
            if (isActive) {
                btn.style.background = '#dc3545';
                btn.style.color = '#fff';
                btn.textContent = 'ğŸ¤ è¯†åˆ«ä¸­...';
            } else {
                btn.style.background = '';
                btn.style.color = '';
                btn.textContent = '@AI';
            }
        }

        // å¼€å§‹é•¿æŒ‰ ASR
        async function startAIButtonASR(event) {
            // è®¾ç½®é•¿æŒ‰è®¡æ—¶å™¨
            aiButtonASR.longPressTimer = setTimeout(async () => {
                aiButtonASR.isLongPress = true;

                // ç«‹å³æš‚åœè¯­éŸ³èŠå¤©çš„éŸ³é¢‘å‘é€ï¼ˆé¿å…é‡å¤ ASRï¼‰
                if (voiceChat.isJoined) {
                    voiceChat.paused = true;
                }

                // æ£€æŸ¥ WebSocket è¿æ¥
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.error('[AI Button ASR] WebSocket æœªè¿æ¥');
                    if (voiceChat.isJoined) {
                        voiceChat.paused = false;
                    }
                    return;
                }

                // é‡ç½®ç´¯ç§¯æ–‡æœ¬
                aiButtonASR.accumulatedText = '';

                // æ¸…ç©ºè¾“å…¥æ¡†å¹¶æ·»åŠ  @ai å‰ç¼€
                const input = document.getElementById('message-input');
                input.value = '@ai ';
                input.focus();

                try {
                    // è·å–éº¦å…‹é£æƒé™
                    const getUserMediaFn = navigator.mediaDevices?.getUserMedia ||
                                          navigator.getUserMedia ||
                                          navigator.webkitGetUserMedia ||
                                          navigator.mozGetUserMedia;

                    if (!getUserMediaFn) {
                        console.error('[AI Button ASR] æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³');
                        return;
                    }

                    const stream = await new Promise((resolve, reject) => {
                        if (navigator.mediaDevices?.getUserMedia) {
                            navigator.mediaDevices.getUserMedia({ audio: true }).then(resolve).catch(reject);
                        } else {
                            navigator.getUserMedia({ audio: true }, resolve, reject);
                        }
                    });

                    aiButtonASR.mediaStream = stream;

                    // åˆ›å»º AudioContext
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    aiButtonASR.audioContext = new AudioContextClass({ sampleRate: 16000 });

                    const source = aiButtonASR.audioContext.createMediaStreamSource(stream);
                    const processor = aiButtonASR.audioContext.createScriptProcessor(4096, 1, 1);
                    aiButtonASR.audioProcessor = processor;

                    source.connect(processor);
                    processor.connect(aiButtonASR.audioContext.destination);

                    // å‘é€å¼€å§‹æ¶ˆæ¯
                    ws.send(JSON.stringify({ type: 'ai_button_asr_start' }));

                    // æ›´æ–°æŒ‰é’®æ ·å¼
                    aiButtonASR.isActive = true;
                    updateAIButtonStyle(true);

                    // å‘é€éŸ³é¢‘æ•°æ®
                    processor.onaudioprocess = (e) => {
                        if (!aiButtonASR.isActive) return;

                        const inputData = e.inputBuffer.getChannelData(0);
                        // è½¬æ¢ä¸º 16bit PCM
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            const s = Math.max(-1, Math.min(1, inputData[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // è½¬æ¢ä¸º base64
                        const base64 = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));

                        // å‘é€åˆ°æœåŠ¡ç«¯
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'ai_button_asr_audio',
                                audioData: base64
                            }));
                        }
                    };

                } catch (error) {
                    console.error('[AI Button ASR] å¯åŠ¨å¤±è´¥:', error);
                    aiButtonASR.isActive = false;
                    updateAIButtonStyle(false);
                    // æ¢å¤è¯­éŸ³èŠå¤©çš„éŸ³é¢‘å‘é€
                    if (voiceChat.isJoined) {
                        voiceChat.paused = false;
                    }
                }
            }, aiButtonASR.longPressThreshold);
        }

        // åœæ­¢é•¿æŒ‰ ASR
        function stopAIButtonASR() {
            // æ¸…é™¤é•¿æŒ‰è®¡æ—¶å™¨
            if (aiButtonASR.longPressTimer) {
                clearTimeout(aiButtonASR.longPressTimer);
                aiButtonASR.longPressTimer = null;
            }

            // å¦‚æœæ˜¯é•¿æŒ‰ï¼Œåœæ­¢è¯­éŸ³è¯†åˆ«
            if (aiButtonASR.isLongPress && aiButtonASR.isActive) {
                // å‘é€åœæ­¢æ¶ˆæ¯
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ai_button_asr_stop' }));
                }

                // åœæ­¢éŸ³é¢‘å½•åˆ¶
                if (aiButtonASR.audioProcessor) {
                    aiButtonASR.audioProcessor.disconnect();
                    aiButtonASR.audioProcessor = null;
                }
                if (aiButtonASR.audioContext) {
                    aiButtonASR.audioContext.close();
                    aiButtonASR.audioContext = null;
                }
                if (aiButtonASR.mediaStream) {
                    aiButtonASR.mediaStream.getTracks().forEach(track => track.stop());
                    aiButtonASR.mediaStream = null;
                }

                aiButtonASR.isActive = false;
                updateAIButtonStyle(false);

                // æ¢å¤è¯­éŸ³èŠå¤©çš„éŸ³é¢‘å‘é€
                if (voiceChat.isJoined) {
                    voiceChat.paused = false;
                }
            }

            aiButtonASR.isLongPress = false;
        }

        // å¤„ç† @AI æŒ‰é’®ç‚¹å‡»
        function handleAIButtonClick(event) {
            // å¦‚æœæ˜¯é•¿æŒ‰è§¦å‘çš„ç‚¹å‡»ï¼Œå¿½ç•¥
            if (aiButtonASR.isLongPress) {
                event.preventDefault();
                return;
            }
            // çŸ­æŒ‰æ—¶æ‰§è¡ŒåŸæœ‰çš„æåŠåŠŸèƒ½
            sendMention('@ai');
        }

        // å¤„ç† @AI æŒ‰é’® ASR ç»“æœ
        function handleAIButtonASRResult(data) {
            const input = document.getElementById('message-input');

            if (data.isFinal) {
                // æœ€ç»ˆç»“æœ
                aiButtonASR.accumulatedText += data.text;
                input.value = '@ai ' + aiButtonASR.accumulatedText;
            } else {
                // ä¸­é—´ç»“æœ
                input.value = '@ai ' + aiButtonASR.accumulatedText + data.text;
            }

            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
        }

        // ===========================================================================
        // èŠå¤©å®¤è¯­éŸ³AIåŠŸèƒ½ï¼ˆç«å±±å¼•æ“å®æ—¶è¯­éŸ³ï¼Œå”¤é†’è¯æ¨¡å¼ï¼‰
        // ===========================================================================

        let chatVoiceAI = {
            isActive: false,
            mode: 'wakeword', // 'wakeword' å”¤é†’ä»‹å…¥ | 'realtime' å®æ—¶ä»‹å…¥
            currentTranscript: '',
            pendingResponse: '', // ç´¯ç§¯AIå“åº”æ–‡æœ¬
            lastAIMsgId: null, // æœ€åä¸€æ¡AIæ¶ˆæ¯çš„ID
            audioChunks: [], // ç´¯ç§¯éŸ³é¢‘å—
            currentAudio: null, // å½“å‰æ’­æ”¾çš„éŸ³é¢‘
            pendingShortText: '', // ç´¯ç§¯çš„çŸ­è¯è¯­ï¼Œç­‰å¾…åˆå¹¶åˆ°ä¸‹ä¸€å¥
        };

        // åˆ‡æ¢èŠå¤©å®¤è¯­éŸ³AI
        async function toggleChatVoiceAI() {
            if (chatVoiceAI.isActive) {
                await stopChatVoiceAI();
            } else {
                await startChatVoiceAI();
            }
        }

        // å¯åŠ¨èŠå¤©å®¤è¯­éŸ³AI
        async function startChatVoiceAI() {
            // æ£€æŸ¥æ˜¯å¦å·²åŠ å…¥è¯­éŸ³èŠå¤©
            if (!voiceChat.isJoined) {
                alert('è¯·å…ˆåŠ å…¥è¯­éŸ³èŠå¤©');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            try {
                // æ£€æŸ¥è¯­éŸ³èŠå¤©çš„éŸ³é¢‘ä¸Šä¸‹æ–‡æ˜¯å¦å­˜åœ¨
                if (!voiceChat.audioContext || !voiceChat.audioProcessor) {
                    throw new Error('è¯­éŸ³èŠå¤©éŸ³é¢‘æœªåˆå§‹åŒ–');
                }

                log('[èŠå¤©å®¤è¯­éŸ³AI] æ­£åœ¨å¯åŠ¨...');

                // å‘é€åŠ å…¥å…±äº«AIæ¶ˆæ¯ï¼ˆä½¿ç”¨å”¤é†’è¯æ¨¡å¼ï¼‰
                ws.send(JSON.stringify({
                    type: 'chat_voice_ai_join',
                    voiceType: 'zh_female_tianmeixiaoyuan_moon_bigtts'
                }));

                // æ›´æ–°UIå’ŒçŠ¶æ€
                chatVoiceAI.isActive = true;
                chatVoiceAI.isSpeaking = false;
                chatVoiceAI.silenceCount = 0;
                chatVoiceAI.speechCount = 0;
                updateChatVoiceAIUI('listening');

                log('[èŠå¤©å®¤è¯­éŸ³AI] å·²å¯åŠ¨ï¼Œè¯´"AI"å¼€å§‹å¯¹è¯');

            } catch (error) {
                console.error('[èŠå¤©å®¤è¯­éŸ³AI] å¯åŠ¨å¤±è´¥:', error);
                alert('è¯­éŸ³AIå¯åŠ¨å¤±è´¥: ' + error.message);
                chatVoiceAI.isActive = false;
                updateChatVoiceAIUI('idle');
            }
        }

        // åœæ­¢èŠå¤©å®¤è¯­éŸ³AI
        async function stopChatVoiceAI() {
            // å‘é€ç¦»å¼€æ¶ˆæ¯
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'chat_voice_ai_leave' }));
            }

            // åœæ­¢éŸ³é¢‘æ’­æ”¾
            if (chatVoiceAI.playbackContext) {
                chatVoiceAI.playbackContext.close();
                chatVoiceAI.playbackContext = null;
            }
            chatVoiceAI.audioQueue = [];
            chatVoiceAI.isPlayingAudio = false;

            // é‡ç½®çŠ¶æ€
            chatVoiceAI.isActive = false;
            chatVoiceAI.isMuted = false;
            chatVoiceAI.isSpeaking = false;
            chatVoiceAI.currentTranscript = '';

            // æ›´æ–°UI
            updateChatVoiceAIUI('idle');

            log('[èŠå¤©å®¤è¯­éŸ³AI] å·²åœæ­¢');
        }

        // åˆ‡æ¢è¯­éŸ³AIæ¨¡å¼
        function toggleChatVoiceAIMode() {
            // åˆ‡æ¢æ¨¡å¼
            chatVoiceAI.mode = chatVoiceAI.mode === 'wakeword' ? 'realtime' : 'wakeword';

            // å‘é€æ¨¡å¼åˆ‡æ¢æ¶ˆæ¯åˆ°æœåŠ¡ç«¯
            if (ws && ws.readyState === WebSocket.OPEN && chatVoiceAI.isActive) {
                ws.send(JSON.stringify({
                    type: 'chat_voice_ai_set_mode',
                    mode: chatVoiceAI.mode
                }));
            }

            // æ›´æ–°UI
            updateChatVoiceAIModeUI();
        }

        // æ›´æ–°æ¨¡å¼UI
        function updateChatVoiceAIModeUI() {
            const btn = document.getElementById('btn-chat-voice-ai-mode');
            const statusText = document.getElementById('chat-voice-ai-status-text');

            if (chatVoiceAI.mode === 'wakeword') {
                btn.style.background = '#6c757d';
                btn.textContent = 'ğŸ”” å”¤é†’æ¨¡å¼';
                if (chatVoiceAI.isActive) {
                    statusText.textContent = 'ğŸ¤ ç›‘å¬ä¸­ - è¯´"AI"å¼€å§‹å¯¹è¯';
                }
            } else {
                btn.style.background = '#17a2b8';
                btn.textContent = 'âš¡ å®æ—¶æ¨¡å¼';
                if (chatVoiceAI.isActive) {
                    statusText.textContent = 'ğŸ¤ å®æ—¶æ¨¡å¼ - è¯´è¯å³å¯å¯¹è¯';
                }
            }
        }

        // æ›´æ–°èŠå¤©å®¤è¯­éŸ³AI UI
        function updateChatVoiceAIUI(state) {
            const btn = document.getElementById('btn-chat-voice-ai');
            const statusDiv = document.getElementById('chat-voice-ai-status');
            const indicator = document.getElementById('chat-voice-ai-indicator');
            const statusText = document.getElementById('chat-voice-ai-status-text');
            const modeBtn = document.getElementById('btn-chat-voice-ai-mode');

            if (state === 'idle') {
                btn.style.background = '';
                btn.textContent = 'ğŸ¤ å¼€å¯è¯­éŸ³AI';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
                statusDiv.style.display = 'none';
                modeBtn.classList.add('hidden');
            } else {
                btn.style.background = '#dc3545';
                btn.textContent = 'ğŸ›‘ åœæ­¢è¯­éŸ³AI';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-danger');
                statusDiv.style.display = 'block';
                modeBtn.classList.remove('hidden');

                if (state === 'listening') {
                    indicator.style.background = '#28a745';
                    if (chatVoiceAI.mode === 'wakeword') {
                        statusText.textContent = 'ğŸ¤ ç›‘å¬ä¸­ - è¯´"AI"å¼€å§‹å¯¹è¯';
                    } else {
                        statusText.textContent = 'ğŸ¤ å®æ—¶æ¨¡å¼ - è¯´è¯å³å¯å¯¹è¯';
                    }
                } else if (state === 'thinking') {
                    indicator.style.background = '#ffc107';
                    statusText.textContent = 'ğŸ¤” AIæ€è€ƒä¸­...';
                } else if (state === 'speaking') {
                    indicator.style.background = '#17a2b8';
                    statusText.textContent = 'ğŸ”Š AIè¯´è¯ä¸­...';
                }

                // æ›´æ–°æ¨¡å¼æŒ‰é’®
                updateChatVoiceAIModeUI();
            }
        }

        // æ˜¾ç¤ºèŠå¤©å®¤è¯­éŸ³AIè½¬å½•
        function showChatVoiceAITranscript(text, isFinal) {
            const transcriptDiv = document.getElementById('chat-voice-ai-transcript');
            transcriptDiv.style.display = 'block';
            transcriptDiv.style.color = isFinal ? '#fff' : '#aaa';
            transcriptDiv.textContent = text;
        }

        // éšè—èŠå¤©å®¤è¯­éŸ³AIè½¬å½•
        function hideChatVoiceAITranscript() {
            const transcriptDiv = document.getElementById('chat-voice-ai-transcript');
            transcriptDiv.style.display = 'none';
            transcriptDiv.textContent = '';
        }

        // å¤„ç†èŠå¤©å®¤è¯­éŸ³AIæ¶ˆæ¯
        function handleChatVoiceAIMessage(data) {
            switch (data.type) {
                case 'chat_voice_ai.started':
                    log('[èŠå¤©å®¤è¯­éŸ³AI] ä¼šè¯å·²å¯åŠ¨');
                    // é‡ç½®çŠ¶æ€
                    chatVoiceAI.pendingResponse = '';
                    chatVoiceAI.lastAIMsgId = null;
                    chatVoiceAI.audioChunks = [];
                    updateChatVoiceAIUI('listening');
                    break;

                case 'chat_voice_ai.stopped':
                    log('[èŠå¤©å®¤è¯­éŸ³AI] ä¼šè¯å·²åœæ­¢');
                    updateChatVoiceAIUI('idle');
                    break;

                case 'chat_voice_ai.state':
                    if (data.state === 'listening') {
                        // AI è¯´è¯ç»“æŸï¼Œæäº¤æœ€ç»ˆæ¶ˆæ¯å¹¶æ’­æ”¾éŸ³é¢‘
                        commitChatVoiceAIResponse();
                        playChatVoiceAIAudio();
                        updateChatVoiceAIUI('listening');
                        hideChatVoiceAITranscript();
                    } else if (data.state === 'thinking') {
                        updateChatVoiceAIUI('thinking');
                    } else if (data.state === 'speaking') {
                        updateChatVoiceAIUI('speaking');
                    }
                    break;

                case 'chat_voice_ai.asr':
                    // ASR è½¬å½•ç»“æœ
                    if (data.text) {
                        showChatVoiceAITranscript(data.text, data.isFinal);

                        // å¦‚æœæ˜¯æœ€ç»ˆç»“æœï¼Œæ˜¾ç¤ºåœ¨èŠå¤©å®¤ä¸­
                        if (data.isFinal) {
                            const trimmedText = data.text.trim();

                            // è¿‡æ»¤çº¯æ— æ„ä¹‰çš„è¯­æ°”è¯ï¼ˆä¸åˆå¹¶ï¼‰
                            const pureIgnoreWords = ['å—¯', 'å•Š', 'å‘ƒ', 'å“¦', 'é¢', 'å””', 'è¯¶', 'å”‰', 'å“ˆ', 'å‘µ', 'å˜˜'];
                            const isPureIgnoreWord = pureIgnoreWords.some(word =>
                                trimmedText === word || trimmedText === word + 'ã€‚' || trimmedText === word + 'ï¼' || trimmedText === word + 'ï¼Ÿ'
                            );

                            if (isPureIgnoreWord) {
                                console.log('[èŠå¤©å®¤è¯­éŸ³AI] å¿½ç•¥è¯­æ°”è¯:', trimmedText);
                                break;
                            }

                            // çŸ­è¯è¯­ï¼ˆâ‰¤2å­—ç¬¦ï¼‰ç´¯ç§¯ç­‰å¾…åˆå¹¶
                            if (trimmedText.length <= 2) {
                                chatVoiceAI.pendingShortText += (chatVoiceAI.pendingShortText ? '' : '') + trimmedText;
                                console.log('[èŠå¤©å®¤è¯­éŸ³AI] ç´¯ç§¯çŸ­è¯è¯­:', trimmedText, 'å½“å‰ç´¯ç§¯:', chatVoiceAI.pendingShortText);
                                break;
                            }

                            // åˆå¹¶ç´¯ç§¯çš„çŸ­è¯è¯­
                            const finalText = chatVoiceAI.pendingShortText + trimmedText;
                            chatVoiceAI.pendingShortText = ''; // æ¸…ç©ºç´¯ç§¯

                            // è®°å½•è¯†åˆ«ç»“æœ
                            console.log('[èŠå¤©å®¤è¯­éŸ³AI] è¯†åˆ«ç»“æœ:', finalText);

                            // åˆ¤æ–­æ˜¯å¦æ˜¯å½“å‰ç”¨æˆ·è¯´çš„è¯
                            const isCurrentUser = (data.userId === userId) ||
                                                  (data.userId === currentUser?.id) ||
                                                  (data.userName === currentUser?.name);

                            if (isCurrentUser) {
                                // ç”¨æˆ·è¯´çš„è¯æ˜¾ç¤ºåœ¨èŠå¤©å®¤
                                const userMsg = {
                                    id: 'voice_' + Date.now(),
                                    type: 'text',
                                    content: `ğŸ¤ ${finalText}`,
                                    senderId: data.userId || userId,
                                    senderName: data.userName || currentUser?.name || 'æˆ‘',
                                    senderRole: 'member',
                                    timestamp: Date.now(),
                                };
                                addMessage(userMsg, true, autoScrollEnabled && !isUserScrollingUp);
                            }
                        }
                    }
                    break;

                case 'chat_voice_ai.response':
                    // AI æ–‡æœ¬å“åº” - ç´¯ç§¯æ–‡æœ¬
                    if (data.text) {
                        chatVoiceAI.pendingResponse += data.text;
                        // æ›´æ–°æˆ–åˆ›å»ºAIæ¶ˆæ¯
                        updateChatVoiceAIResponse();
                    }
                    break;

                case 'chat_voice_ai.audio':
                    // AI éŸ³é¢‘å“åº” - ç´¯ç§¯éŸ³é¢‘å—
                    if (data.audioData) {
                        queueChatVoiceAIAudio(data.audioData);
                    }
                    break;

                case 'chat_voice_ai.mode_changed':
                    // æ¨¡å¼åˆ‡æ¢æˆåŠŸ
                    chatVoiceAI.mode = data.mode;
                    updateChatVoiceAIModeUI();
                    log(`[èŠå¤©å®¤è¯­éŸ³AI] æ¨¡å¼å·²åˆ‡æ¢ä¸º: ${data.mode === 'wakeword' ? 'å”¤é†’ä»‹å…¥' : 'å®æ—¶ä»‹å…¥'}`);
                    break;

                case 'chat_voice_ai.error':
                    console.error('[èŠå¤©å®¤è¯­éŸ³AI] é”™è¯¯:', data.error);
                    addSystemMessage(`è¯­éŸ³AIé”™è¯¯: ${data.error}`, 'error');
                    // å‡ºé”™æ—¶åœæ­¢è¯­éŸ³AIï¼Œæ¢å¤è¯­éŸ³èŠå¤©çš„ ASR
                    chatVoiceAI.isActive = false;
                    updateChatVoiceAIUI('idle');
                    break;
            }
        }

        // æ›´æ–°æˆ–åˆ›å»ºAIå“åº”æ¶ˆæ¯ï¼ˆå®æ—¶æ›´æ–°ï¼‰
        function updateChatVoiceAIResponse() {
            const content = chatVoiceAI.pendingResponse;
            if (!content) return;

            if (chatVoiceAI.lastAIMsgId) {
                // æ›´æ–°ç°æœ‰æ¶ˆæ¯
                updateMessageContent(chatVoiceAI.lastAIMsgId, content);
            } else {
                // åˆ›å»ºæ–°æ¶ˆæ¯ï¼ˆskipSidebar=trueï¼Œä¸æ·»åŠ åˆ°AIå›å¤ä¾§è¾¹æ ï¼‰
                const aiMsg = {
                    id: 'ai_voice_' + Date.now(),
                    type: 'text',
                    content: content,
                    senderId: 'ai-assistant',
                    senderName: 'AIåŠ©æ‰‹',
                    senderRole: 'ai',
                    timestamp: Date.now(),
                };
                addMessage(aiMsg, false, autoScrollEnabled && !isUserScrollingUp, true);
                chatVoiceAI.lastAIMsgId = aiMsg.id;
            }
        }

        // æäº¤æœ€ç»ˆAIå“åº”ï¼ˆAIè¯´è¯ç»“æŸæ—¶è°ƒç”¨ï¼‰
        function commitChatVoiceAIResponse() {
            // é‡ç½®ç´¯ç§¯çŠ¶æ€
            chatVoiceAI.pendingResponse = '';
            chatVoiceAI.lastAIMsgId = null;
        }

        // æ›´æ–°æ¶ˆæ¯å†…å®¹
        function updateMessageContent(messageId, newContent) {
            const msgElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (msgElement) {
                const contentEl = msgElement.querySelector('.message-content');
                if (contentEl) {
                    contentEl.innerHTML = markdownToHtml(newContent);
                }
            }
        }

        // ç´¯ç§¯èŠå¤©å®¤è¯­éŸ³AIéŸ³é¢‘
        function queueChatVoiceAIAudio(base64Audio) {
            try {
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                chatVoiceAI.audioChunks.push(bytes);
            } catch (error) {
                console.error('[èŠå¤©å®¤è¯­éŸ³AI] Failed to queue audio:', error);
            }
        }

        // æ’­æ”¾èŠå¤©å®¤è¯­éŸ³AIéŸ³é¢‘ï¼ˆå¤ç”¨å…±äº«AIçš„é€»è¾‘ï¼‰
        async function playChatVoiceAIAudio() {
            if (chatVoiceAI.audioChunks.length === 0) {
                return;
            }

            try {
                // åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
                const totalLength = chatVoiceAI.audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chatVoiceAI.audioChunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }

                // æ¸…ç©ºéŸ³é¢‘å—
                chatVoiceAI.audioChunks = [];

                // åˆ›å»º Blobï¼ˆä½¿ç”¨ ogg æ ¼å¼ï¼‰
                const blob = new Blob([combined], { type: 'audio/ogg' });
                const url = URL.createObjectURL(blob);

                // åœæ­¢ä¹‹å‰çš„éŸ³é¢‘
                if (chatVoiceAI.currentAudio) {
                    chatVoiceAI.currentAudio.pause();
                    chatVoiceAI.currentAudio = null;
                }

                // æ’­æ”¾æ–°éŸ³é¢‘
                const audio = new Audio(url);
                chatVoiceAI.currentAudio = audio;

                audio.onended = () => {
                    URL.revokeObjectURL(url);
                    chatVoiceAI.currentAudio = null;
                };

                audio.onerror = (e) => {
                    console.error('[èŠå¤©å®¤è¯­éŸ³AI] Audio error:', audio.error?.message);
                    URL.revokeObjectURL(url);
                    chatVoiceAI.currentAudio = null;
                };

                await audio.play();
            } catch (error) {
                console.error('[èŠå¤©å®¤è¯­éŸ³AI] Failed to play audio:', error);
            }
        }

        // å¤„ç†å›è½¦é”®
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // ç®€å•çš„ Markdown è½¬æ¢
        function markdownToHtml(text) {
            if (!text) return '';
            return text
                .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                .replace(/\n/g, '<br>');
        }

        // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åº”è¯¥æ·»åŠ åˆ°ä¾§è¾¹æ 
        function shouldAddToSidebar(message) {
            const isAIMessage = message.senderRole === 'ai' || message.senderId === 'ai-assistant';
            const content = message.content || '';
            const hasMention = content.includes('@ai') || content.includes('@all') || /@\w+/.test(content);
            return (hasMention && !isAIMessage) || isAIMessage;
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°ä¾§è¾¹æ 
        // append = false: æ’å…¥åˆ°é¡¶éƒ¨ï¼ˆæ–°æ¶ˆæ¯ï¼‰
        // append = true: è¿½åŠ åˆ°åº•éƒ¨ï¼ˆå†å²æ¶ˆæ¯ï¼‰
        function addToSidebar(message, append = false) {
            const isAIMessage = message.senderRole === 'ai' || message.senderId === 'ai-assistant';
            const content = message.content || '';
            const senderName = message.senderName || message.userName || 'æœªçŸ¥ç”¨æˆ·';
            const messageId = message.id;
            // ä¾§è¾¹æ ä½¿ç”¨ç´§å‡‘æ ¼å¼ï¼šMM-DD HH:MM
            const date = message.timestamp ? new Date(message.timestamp) : new Date();
            const timestamp = `${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;

            // æ£€æŸ¥æ˜¯å¦æ˜¯@æåŠæ¶ˆæ¯ï¼ˆåŒ…å«@aiæˆ–@allæˆ–å…¶ä»–@ï¼‰
            const hasMention = content.includes('@ai') || content.includes('@all') || /@\w+/.test(content);

            // æ·»åŠ åˆ°@æåŠä¾§è¾¹æ 
            if (hasMention && !isAIMessage) {
                const mentionsList = document.getElementById('mentions-list');
                // ç§»é™¤ç©ºçŠ¶æ€
                const emptyDiv = mentionsList.querySelector('.sidebar-empty');
                if (emptyDiv) emptyDiv.remove();

                const preview = content.replace(/@\w+/g, '').trim().substring(0, 30) || '@æåŠ';
                const item = document.createElement('div');
                item.className = 'sidebar-item sidebar-item-mention';
                item.setAttribute('data-message-id', messageId);
                item.innerHTML = `
                    <div class="sidebar-item-sender">${senderName}</div>
                    <div class="sidebar-item-preview">${preview}...</div>
                    <div class="sidebar-item-time">${timestamp}</div>
                `;
                item.onclick = () => scrollToMessage(messageId);

                if (append) {
                    mentionsList.appendChild(item);
                } else {
                    mentionsList.insertBefore(item, mentionsList.firstChild);
                }

                // é™åˆ¶æ•°é‡
                while (mentionsList.children.length > 20) {
                    if (append) {
                        mentionsList.removeChild(mentionsList.firstChild);
                    } else {
                        mentionsList.removeChild(mentionsList.lastChild);
                    }
                }
            }

            // æ·»åŠ åˆ°AIå›å¤ä¾§è¾¹æ 
            if (isAIMessage) {
                const aiList = document.getElementById('ai-responses-list');
                // ç§»é™¤ç©ºçŠ¶æ€
                const emptyDiv = aiList.querySelector('.sidebar-empty');
                if (emptyDiv) emptyDiv.remove();

                const preview = content.replace(/```[\s\S]*?```/g, '[ä»£ç ]').substring(0, 30) || 'AIå›å¤';
                const item = document.createElement('div');
                item.className = 'sidebar-item sidebar-item-ai';
                item.setAttribute('data-message-id', messageId);
                item.innerHTML = `
                    <div class="sidebar-item-sender">AIåŠ©æ‰‹</div>
                    <div class="sidebar-item-preview">${preview}...</div>
                    <div class="sidebar-item-time">${timestamp}</div>
                `;
                item.onclick = () => scrollToMessage(messageId);

                if (append) {
                    aiList.appendChild(item);
                } else {
                    aiList.insertBefore(item, aiList.firstChild);
                }

                // é™åˆ¶æ•°é‡
                while (aiList.children.length > 20) {
                    if (append) {
                        aiList.removeChild(aiList.firstChild);
                    } else {
                        aiList.removeChild(aiList.lastChild);
                    }
                }
            }
        }

        // æ»šåŠ¨åˆ°æŒ‡å®šæ¶ˆæ¯
        function scrollToMessage(messageId) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageEl) {
                messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // é«˜äº®æ•ˆæœ
                messageEl.style.transition = 'box-shadow 0.3s';
                messageEl.style.boxShadow = '0 0 15px #666';
                setTimeout(() => {
                    messageEl.style.boxShadow = '';
                }, 1500);

                // ç‚¹å‡»AIå›å¤æ—¶ç¦ç”¨è‡ªåŠ¨æ»šåŠ¨
                if (autoScrollEnabled) {
                    autoScrollEnabled = false;
                    updateAutoScrollButton();
                }
            }
        }

        // åˆ‡æ¢è‡ªåŠ¨æ»šåŠ¨
        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            updateAutoScrollButton();

            // å¦‚æœå¯ç”¨è‡ªåŠ¨æ»šåŠ¨ï¼Œç«‹å³æ»šåŠ¨åˆ°åº•éƒ¨
            if (autoScrollEnabled) {
                const container = document.getElementById('chat-container');
                container.scrollTop = container.scrollHeight;
                isUserScrollingUp = false;
            }
        }

        // æ›´æ–°è‡ªåŠ¨æ»šåŠ¨æŒ‰é’®çŠ¶æ€
        function updateAutoScrollButton() {
            const btn = document.getElementById('btn-auto-scroll');
            if (btn) {
                if (autoScrollEnabled) {
                    btn.textContent = 'è‡ªåŠ¨æ»šåŠ¨';
                    btn.style.background = '#28a745';
                    btn.style.color = '#fff';
                } else {
                    btn.textContent = 'è‡ªåŠ¨æ»šåŠ¨å·²æš‚åœ';
                    btn.style.background = '#6c757d';
                    btn.style.color = '#fff';
                }
            }
        }

        // åˆ‡æ¢AIæ¶ˆæ¯å±•å¼€/æŠ˜å 
        function toggleAIContent(messageId) {
            const contentEl = document.querySelector(`[data-ai-content="${messageId}"]`);
            const btnEl = document.querySelector(`[data-ai-btn="${messageId}"]`);
            if (contentEl && btnEl) {
                const isExpanded = contentEl.classList.contains('ai-content-expanded');
                if (isExpanded) {
                    contentEl.classList.remove('ai-content-expanded');
                    btnEl.textContent = '[å±•å¼€]';
                } else {
                    contentEl.classList.add('ai-content-expanded');
                    btnEl.textContent = '[æ”¶èµ·]';
                }
            }
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒº
        function addMessage(message, isOwn, shouldScroll = true, skipSidebar = false) {
            const container = document.getElementById('chat-container');
            const div = document.createElement('div');

            const isAIMessage = message.senderRole === 'ai' || message.senderId === 'ai-assistant';

            if (isAIMessage) {
                div.className = 'message message-ai';
            } else {
                div.className = `message ${isOwn ? 'message-own' : 'message-other'}`;
            }

            if (message.id) {
                div.setAttribute('data-message-id', message.id);
            }

            let contentHtml = highlightMentions(message.content || '');

            if (message.type === 'file' && message.fileData) {
                const fileData = message.fileData;
                const fileIcon = getFileIcon(fileData.mimeType || '');
                const fileSize = formatFileSize(fileData.fileSize || 0);


                if (message.id) {
                    div.setAttribute('data-file-id', message.id);
                }
                if (fileData.ossUrl) {
                    div.setAttribute('data-oss-url', fileData.ossUrl);
                }
                if (fileData.ossKey) {
                    div.setAttribute('data-oss-key', fileData.ossKey);
                }

                // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé€šè¿‡ data å±æ€§å­˜å‚¨æ•°æ®
                const downloadBtnId = 'dl-btn-' + message.id;
                if (fileData.ossUrl) {
                    pendingFileDownloads.set(downloadBtnId, {
                        url: fileData.ossUrl,
                        filename: fileData.fileName || 'download',
                        ossKey: fileData.ossKey || ''
                    });
                }

                contentHtml = `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #333; border-radius: 8px; margin-top: 5px;">
                        <span style="font-size: 24px;">${fileIcon}</span>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${fileData.fileName || 'æœªçŸ¥æ–‡ä»¶'}</div>
                            <div style="font-size: 12px; color: #fff;">${fileSize}</div>
                        </div>
                        ${fileData.ossUrl
                            ? `<button id="${downloadBtnId}" class="file-download-btn" style="color: #fff; background: #2a2a2a; border: none; padding: 5px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;">ä¸‹è½½</button>`
                            : '<span style="font-size: 12px; color: #fff;">ä¸Šä¼ ä¸­...</span>'}
                    </div>
                `;
            } else if (isAIMessage) {
                const fullContent = markdownToHtml(message.content || '');
                const plainText = message.content || '';
                const previewText = plainText.substring(0, 20);
                const needsExpansion = plainText.length > 20;

                if (needsExpansion) {
                    contentHtml = `
                        <div class="ai-content-collapsed" data-ai-content="${message.id}">
                            <span class="ai-content-preview">${previewText}</span>
                            <span class="ai-expand-btn" data-ai-btn="${message.id}" onclick="toggleAIContent('${message.id}')">[å±•å¼€]</span>
                            <div class="ai-content-full">${fullContent}</div>
                        </div>
                    `;
                } else {
                    contentHtml = fullContent;
                }
            }

            if (message.type === 'image' && message.imageData) {
                const imgUrl = message.imageData.url || message.imageData.ossUrl;
                if (imgUrl) {
                    contentHtml = `<img src="${imgUrl}" style="max-width: 100%; border-radius: 8px; margin-top: 5px;" />`;
                }
            }

            const senderName = message.senderName || message.userName || 'æœªçŸ¥ç”¨æˆ·';
            const senderId = message.senderId || message.userId || 'unknown';
            const timestamp = message.timestamp ? new Date(message.timestamp).toLocaleString() : new Date().toLocaleString();

            // è·å–ç”¨æˆ·é¢œè‰²ï¼ˆAIæ¶ˆæ¯å’Œè‡ªå·±æ¶ˆæ¯ä½¿ç”¨é»˜è®¤é¢œè‰²ï¼‰
            let headerStyle = '';
            if (!isAIMessage && !isOwn) {
                const userColor = getChatUserColor(senderId);
                headerStyle = `style="color: ${userColor};"`;
            }

            div.innerHTML = `
                <div class="message-header" ${headerStyle}>${senderName} Â· ${timestamp}</div>
                <div class="message-content">${contentHtml}</div>
            `;

            container.appendChild(div);

            // æ·»åŠ åˆ°ä¾§è¾¹æ ï¼ˆé™¤éæ˜ç¡®è·³è¿‡ï¼‰
            if (!skipSidebar) {
                addToSidebar(message);
            }

            if (shouldScroll) {
                container.scrollTop = container.scrollHeight;
            }
        }

        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
        function addSystemMessage(text, type = 'info') {
            const container = document.getElementById('chat-container');
            const div = document.createElement('div');
            div.className = 'message message-system';
            div.textContent = text;
            container.appendChild(div);

            if (autoScrollEnabled && !isUserScrollingUp) {
                container.scrollTop = container.scrollHeight;
            }
        }

        // å‘é€ç³»ç»Ÿæ¶ˆæ¯ï¼ˆæœ¬åœ°æ˜¾ç¤ºï¼‰
        function sendSystemMessage(text) {
            addSystemMessage(text);
        }

        // é«˜äº®æåŠ
        function highlightMentions(text) {
            return text
                .replace(/@ai/g, '<span class="mention">@ai</span>')
                .replace(/@all/g, '<span class="mention">@all</span>')
                .replace(/@\w+/g, match => `<span class="mention">${match}</span>`);
        }

        // æ·»åŠ å‚ä¸è€…
        function addParticipant(user) {
            const userId = user.userId || user.id;
            if (userId) {
                participants.set(userId, {
                    userId: userId,
                    userName: user.userName || user.name || user.user_name || 'æœªçŸ¥ç”¨æˆ·',
                    userRole: user.userRole || user.role || 'guest'
                });
                updateParticipantsList();
            }
        }

        // ç§»é™¤å‚ä¸è€…
        function removeParticipant(userId) {
            if (userId) {
                participants.delete(userId);
                updateParticipantsList();
            }
        }

        // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
        function updateParticipantsList() {
            const container = document.getElementById('participants');
            container.innerHTML = '';

            participants.forEach(user => {
                const div = document.createElement('div');
                div.className = 'participant';
                const role = user.userRole || 'guest';
                div.innerHTML = `
                    <span class="participant-role role-${role}"></span>
                    <span>${user.userName || 'æœªçŸ¥ç”¨æˆ·'}</span>
                `;
                container.appendChild(div);
            });
        }

        // æ€»ç»“èŠå¤©
        function summarizeChat() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            const message = {
                type: 'summarize'
            };

            ws.send(JSON.stringify(message));
            log('å‘é€æ€»ç»“èŠå¤©è¯·æ±‚');
        }

        // æ˜¾ç¤ºæ€»ç»“
        function displaySummary(summary) {
            const displayDiv = document.getElementById('summary-display');
            const contentDiv = document.getElementById('summary-content');

            if (displayDiv && contentDiv) {
                contentDiv.innerHTML = markdownToHtml(summary);
                displayDiv.style.display = 'block';
            }
        }

        // éšè—æ€»ç»“
        function hideSummary() {
            const displayDiv = document.getElementById('summary-display');
            if (displayDiv) {
                displayDiv.style.display = 'none';
            }
        }

        // æ¸…ç©ºAIè®°å¿†
        function clearAIMemory() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            if (!confirm('ç¡®å®šè¦æ¸…ç©ºAIè®°å¿†å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰å¯¹è¯æ€»ç»“ã€‚')) {
                return;
            }

            const message = {
                type: 'clear_ai_memory'
            };

            ws.send(JSON.stringify(message));
            log('å‘é€æ¸…ç©ºAIè®°å¿†è¯·æ±‚');
        }

        // æ–‡ä»¶ä¸Šä¼ ç›¸å…³å˜é‡
        let currentUpload = null;

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            log(`å‡†å¤‡ä¸Šä¼ æ–‡ä»¶: ${file.name} (${formatFileSize(file.size)})`);
            await uploadFile(file);
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // è·å–æ–‡ä»¶å›¾æ ‡
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return '';
            if (mimeType.startsWith('video/')) return '';
            if (mimeType.startsWith('audio/')) return '';
            if (mimeType.includes('pdf')) return '';
            if (mimeType.includes('word') || mimeType.includes('document')) return '';
            if (mimeType.includes('excel') || mimeType.includes('sheet')) return '';
            if (mimeType.includes('zip') || mimeType.includes('compressed')) return '';
            return '';
        }

        // ä¸Šä¼ æ–‡ä»¶
        async function uploadFile(file) {
            const progressDiv = document.getElementById('upload-progress');
            const progressBar = document.getElementById('upload-bar');
            const statusSpan = document.getElementById('upload-status');

            progressDiv.style.display = 'block';
            progressBar.style.width = '0%';
            statusSpan.textContent = 'å‡†å¤‡ä¸Šä¼ ...';

            try {
                const fileId = 'file-' + Date.now();

                const message = {
                    type: 'message',
                    message: {
                        id: fileId,
                        type: 'file',
                        content: `${getFileIcon(file.type)} ä¸Šä¼ æ–‡ä»¶: ${file.name}`,
                        fileData: {
                            fileName: file.name,
                            fileSize: file.size,
                            mimeType: file.type || 'application/octet-stream'
                        },
                        mentions: [],
                        mentionsAI: false
                    }
                };

                statusSpan.textContent = 'è·å–ä¸Šä¼ åœ°å€...';
                progressBar.style.width = '20%';

                ws.send(JSON.stringify(message));
                log(`å·²å‘é€æ–‡ä»¶å…ƒæ•°æ®ï¼Œç­‰å¾…æœåŠ¡å™¨ç”ŸæˆOSSä¸Šä¼ åœ°å€...`);

                const uploadUrl = await waitForUploadUrl(fileId);

                if (!uploadUrl) {
                    throw new Error('æœªèƒ½è·å–ä¸Šä¼ åœ°å€ï¼ŒæœåŠ¡å™¨å¯èƒ½æœªå¯ç”¨OSS');
                }

                log(`è·å–åˆ°OSSä¸Šä¼ åœ°å€ï¼Œå¼€å§‹ä¸Šä¼ æ–‡ä»¶...`);
                statusSpan.textContent = 'ä¸Šä¼ åˆ°äº‘å­˜å‚¨...';
                progressBar.style.width = '50%';

                const xhr = new XMLHttpRequest();

                currentUpload = xhr;

                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 40) + 50;
                        progressBar.style.width = percent + '%';
                        statusSpan.textContent = `ä¸Šä¼ ä¸­... ${Math.round((e.loaded / e.total) * 100)}%`;
                    }
                });

                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        progressBar.style.width = '100%';
                        statusSpan.textContent = 'ä¸Šä¼ å®Œæˆ!';
                        log(`æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ${file.name}`);

                        setTimeout(() => {
                            progressDiv.style.display = 'none';
                            progressBar.style.width = '0%';
                        }, 2000);

                        sendFileUploadedMessage(fileId, file.name, file.size, file.type);
                    } else {
                        throw new Error(`ä¸Šä¼ å¤±è´¥: ${xhr.status}`);
                    }
                });

                xhr.addEventListener('error', () => {
                    throw new Error('ç½‘ç»œé”™è¯¯');
                });

                xhr.open('PUT', uploadUrl, true);
                xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
                xhr.send(file);

            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                statusSpan.textContent = 'ä¸Šä¼ å¤±è´¥: ' + error.message;
                progressBar.style.background = '#888';
                log('ä¸Šä¼ å¤±è´¥: ' + error.message);

                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    progressBar.style.width = '0%';
                    progressBar.style.background = '#666';
                }, 3000);
            }
        }

        // ===========================================================================
        // æ–‡ä»¶ä¸‹è½½ä¸­å¿ƒåŠŸèƒ½
        // ===========================================================================

        // å­˜å‚¨æ–‡ä»¶åˆ—è¡¨
        let aiGeneratedFiles = [];
        let sharedFiles = [];

        // å­˜å‚¨å¾…å¤„ç†çš„ä¸‹è½½URLåˆ·æ–°è¯·æ±‚
        const pendingDownloadRequests = new Map();

        // å­˜å‚¨å¾…ä¸‹è½½æ–‡ä»¶ä¿¡æ¯ï¼ˆç”¨äºäº‹ä»¶å§”æ‰˜ï¼‰
        const pendingFileDownloads = new Map();

        // è®¾ç½®æ–‡ä»¶ä¸‹è½½æŒ‰é’®äº‹ä»¶å§”æ‰˜
        function setupFileDownloadDelegation() {
            document.addEventListener('click', function(e) {
                if (e.target && e.target.classList.contains('file-download-btn')) {
                    e.preventDefault();
                    e.stopPropagation();

                    // å°è¯•ä» id è·å–ï¼ˆèŠå¤©æ¶ˆæ¯ï¼‰
                    const btnId = e.target.id;
                    if (btnId) {
                        const fileInfo = pendingFileDownloads.get(btnId);
                        if (fileInfo) {
                            handleFileDownload(fileInfo.url, fileInfo.filename, fileInfo.ossKey);
                            return;
                        }
                    }

                    // å°è¯•ä» data-download-id è·å–ï¼ˆæ–‡ä»¶ä¸‹è½½ä¸­å¿ƒï¼‰
                    const downloadId = e.target.getAttribute('data-download-id');
                    if (downloadId) {
                        const fileInfo = pendingFileDownloads.get(downloadId);
                        if (fileInfo) {
                            handleFileDownload(fileInfo.url, fileInfo.filename, fileInfo.ossKey);
                        } else {
                            console.error('[Download] No file info found for downloadId:', downloadId);
                        }
                    }
                }
            });
        }

        // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨ï¼ˆä»é¡µé¢æ¶ˆæ¯ä¸­æå–ï¼‰
        function refreshFileList() {
            extractFilesFromMessages();
            displayFileList('all');
            log('æ–‡ä»¶åˆ—è¡¨å·²åˆ·æ–°');
        }

        // åˆ—å‡ºAIç”Ÿæˆçš„æ–‡ä»¶
        function listAIFiles() {
            extractFilesFromMessages();
            displayFileList('ai');
        }

        // åˆ—å‡ºå…±äº«æ–‡ä»¶
        function listSharedFiles() {
            extractFilesFromMessages();
            displayFileList('shared');
        }

        // ===========================================================================
        // æ–‡ä»¶ç®¡ç†åŠŸèƒ½ï¼ˆä»… Admin å’Œ Owner å¯ç”¨ï¼‰
        // ===========================================================================

        // å­˜å‚¨ä¼šè¯æ–‡ä»¶åˆ—è¡¨ï¼ˆç”¨äºç®¡ç†ï¼‰
        let sessionFilesForManage = [];

        // è¯·æ±‚æ–‡ä»¶åˆ—è¡¨è¿›è¡Œç®¡ç†
        function listSessionFilesForManage() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            const message = {
                type: 'list_session_files'
            };
            ws.send(JSON.stringify(message));
            log('è¯·æ±‚æ–‡ä»¶åˆ—è¡¨è¿›è¡Œç®¡ç†...');
        }

        // åˆ é™¤æ–‡ä»¶
        function deleteFile(fileId, fileName) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${fileName}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
                return;
            }

            const message = {
                type: 'delete_file',
                fileId: fileId
            };
            ws.send(JSON.stringify(message));
            log(`è¯·æ±‚åˆ é™¤æ–‡ä»¶: ${fileName}`);
        }

        // é‡å‘½åæ–‡ä»¶
        function renameFile(fileId, oldFileName) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            const newName = prompt(`è¯·è¾“å…¥æ–°æ–‡ä»¶å:`, oldFileName);
            if (!newName || newName === oldFileName) {
                return;
            }

            const message = {
                type: 'rename_file',
                fileId: fileId,
                newFileName: newName
            };
            ws.send(JSON.stringify(message));
            log(`è¯·æ±‚é‡å‘½åæ–‡ä»¶: ${oldFileName} -> ${newName}`);
        }

        // æ˜¾ç¤ºæ–‡ä»¶ç®¡ç†åˆ—è¡¨
        function displayManageFileList(files) {
            const container = document.getElementById('file-list-container');
            sessionFilesForManage = files;

            if (!files || files.length === 0) {
                container.innerHTML = '<div style="color: #fff; text-align: center; padding: 20px;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }

            const userRole = document.getElementById('user-role').value;
            const canManage = userRole === 'admin' || userRole === 'owner';

            let html = '<div style="font-size: 12px; color: #fff; margin-bottom: 10px;">å…± ' + files.length + ' ä¸ªæ–‡ä»¶</div>';

            files.forEach(file => {
                const size = formatFileSize(file.fileSize);
                const date = new Date(file.uploadedAt).toLocaleString();

                html += `
                    <div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 32px;">ğŸ“„</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: bold; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${escapeHtml(file.fileName)}
                            </div>
                            <div style="font-size: 12px; color: #fff; margin-top: 4px;">
                                å¤§å°: ${size} | ä¸Šä¼ è€…: ${escapeHtml(file.uploadedBy || 'æœªçŸ¥')} | ${date}
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <a href="${file.ossUrl || '#'})" target="_blank" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px; text-decoration: none;">ä¸‹è½½</a>
                            ${canManage ? `
                                <button onclick="renameFile('${file.id}', '${escapeHtml(file.fileName)}')" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">é‡å‘½å</button>
                                <button onclick="deleteFile('${file.id}', '${escapeHtml(file.fileName)}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;">åˆ é™¤</button>
                            ` : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (!bytes) return 'æœªçŸ¥';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }

        // HTMLè½¬ä¹‰
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ä»æ¶ˆæ¯ä¸­æå–æ–‡ä»¶ä¿¡æ¯
        function extractFilesFromMessages() {
            aiGeneratedFiles = [];
            sharedFiles = [];

            // ä»èŠå¤©è®°å½•ä¸­æå–AIç”Ÿæˆçš„æ–‡ä»¶
            chatHistory.forEach((msg, index) => {
                // æ£€æŸ¥AIæ¶ˆæ¯ä¸­çš„æ–‡ä»¶ï¼ˆæ”¯æŒå¤šç§senderRoleæ ¼å¼ï¼‰
                const isAIMessage = msg.senderRole === 'ai' || msg.senderId === 'ai-assistant' || msg.sender_role === 'ai';
                if (isAIMessage && msg.content) {
                    // æŸ¥æ‰¾æ‰€æœ‰ä¸‹è½½é“¾æ¥ï¼ˆæ”¯æŒå®Œæ•´URLå’Œæœ¬åœ°è·¯å¾„ï¼‰
                    // åŒ¹é…æ¨¡å¼ï¼šä¸‹è½½é“¾æ¥ï¼šURL æˆ– - ä¸‹è½½é“¾æ¥ï¼šURL æˆ– ğŸ”— ä¸‹è½½é“¾æ¥ï¼šURL æˆ–ç›´æ¥åŒ…å«/downloads/çš„é“¾æ¥
                    const links = [];
                    const seen = new Set();

                    // æ¨¡å¼1: æ ‡å‡†"ä¸‹è½½é“¾æ¥ï¼š"æ ¼å¼
                    const downloadLinkRegex = /ä¸‹è½½é“¾æ¥[ï¼š:]\s*(https?:\/\/[^\s\n]+|\/[^\s\n]+)/gi;
                    let match;
                    while ((match = downloadLinkRegex.exec(msg.content)) !== null) {
                        if (!seen.has(match[1])) {
                            links.push(match[1]);
                            seen.add(match[1]);
                        }
                    }

                    // æ¨¡å¼2: åˆ—è¡¨é¡¹æ ¼å¼ "- ä¸‹è½½é“¾æ¥ï¼šURL"
                    const listItemRegex = /-\s*ä¸‹è½½é“¾æ¥[ï¼š:]\s*(https?:\/\/[^\s\n]+|\/[^\s\n]+)/gi;
                    while ((match = listItemRegex.exec(msg.content)) !== null) {
                        if (!seen.has(match[1])) {
                            links.push(match[1]);
                            seen.add(match[1]);
                        }
                    }

                    // æ¨¡å¼3: ä»»ä½•/downloads/å¼€å¤´çš„æœ¬åœ°è·¯å¾„ï¼ˆæ’é™¤å°¾éšæ ‡ç‚¹ï¼‰
                    const localPathRegex = /(\/downloads\/[^\s\n`"'<>]+)/gi;
                    while ((match = localPathRegex.exec(msg.content)) !== null) {
                        const cleanUrl = match[1].replace(/[`"'<>]+$/, '');
                        if (!seen.has(cleanUrl)) {
                            links.push(cleanUrl);
                            seen.add(cleanUrl);
                        }
                    }

                    // æ¨¡å¼4: ä»»ä½•OSS URL (åŒ…å«oss-cn-beijing.aliyuncs.com)ï¼ˆæ’é™¤å°¾éšæ ‡ç‚¹ï¼‰
                    const ossRegex = /(https?:\/\/[^\s\n`"'<>]*oss[^\s\n`"'<>]*\.aliyuncs\.com[^\s\n`"'<>]*)/gi;
                    while ((match = ossRegex.exec(msg.content)) !== null) {
                        const cleanUrl = match[1].replace(/[`"'<>]+$/, '');
                        if (!seen.has(cleanUrl)) {
                            links.push(cleanUrl);
                            seen.add(cleanUrl);
                        }
                    }


                    // ä¸ºæ¯ä¸ªé“¾æ¥æå–æ–‡ä»¶å
                    links.forEach(url => {

                        // é¦–å…ˆå°è¯•ä»URLç›´æ¥æå–æ–‡ä»¶å
                        const urlParts = url.split('/');
                        const lastPart = urlParts[urlParts.length - 1];
                        let filename = null;
                        try {
                            filename = decodeURIComponent(lastPart);
                        } catch (e) {
                            filename = lastPart;
                        }

                        // å°è¯•ä»URLä¸Šæ–¹çš„è¡ŒæŸ¥æ‰¾æ›´å¥½çš„æ–‡ä»¶å
                        const urlIndex = msg.content.indexOf(url);
                        if (urlIndex > 0) {
                            const contentBeforeUrl = msg.content.substring(0, urlIndex);
                            const lines = contentBeforeUrl.split('\n');

                            // ä»åå‘å‰æŸ¥æ‰¾æ–‡ä»¶å
                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (!line) continue;

                                // æ¨¡å¼1: "1. æ–‡ä»¶å.txt - æè¿°"
                                const numberedMatch = line.match(/^[\d]+\.\s*(.+?)(?:\s+-\s+|$)/);
                                if (numberedMatch) {
                                    const potentialName = numberedMatch[1].trim();
                                    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰©å±•å
                                    if (/\.\w{2,10}$/.test(potentialName)) {
                                        filename = potentialName;
                                        break;
                                    }
                                }

                                // æ¨¡å¼2: "æ–‡ä»¶å[ï¼š:]" æˆ– "ğŸ“„ æ–‡ä»¶å"
                                const labelMatch = line.match(/(?:æ–‡ä»¶å[ï¼š:]|ğŸ“„)\s*(.+)/i);
                                if (labelMatch) {
                                    const potentialName = labelMatch[1].trim();
                                    if (/\.\w{2,10}$/.test(potentialName)) {
                                        filename = potentialName;
                                        break;
                                    }
                                }

                                // æ¨¡å¼3: å¦‚æœè¿™ä¸€è¡Œåªæ˜¯æ–‡ä»¶åï¼ˆåŒ…å«æ‰©å±•åï¼‰
                                if (/\.\w{2,10}$/.test(line) && !line.includes('ï¼š') && !line.includes(':') && line.length < 100) {
                                    filename = line;
                                    break;
                                }
                            }
                        }


                        // å°è¯•ä»URLä¸­æå–ossKey
                        let extractedOssKey = '';
                        if (url.includes('aliyuncs.com')) {
                            const match = url.match(/aliyuncs\.com\/(.+?)(\?|$)/);
                            if (match) {
                                extractedOssKey = decodeURIComponent(match[1]);
                            }
                        }

                        aiGeneratedFiles.push({
                            filename: filename || 'æœªçŸ¥æ–‡ä»¶',
                            url: url,
                            ossKey: extractedOssKey,
                            timestamp: msg.timestamp,
                            sender: msg.senderName,
                            type: 'ai'
                        });
                    });
                }

                // æ£€æŸ¥æ–‡ä»¶åˆ†äº«æ¶ˆæ¯
                if (msg.type === 'file' || (msg.fileData && msg.fileData.ossUrl)) {
                    sharedFiles.push({
                        filename: msg.fileData?.fileName || msg.fileName || 'æœªçŸ¥æ–‡ä»¶',
                        url: msg.fileData?.ossUrl || msg.fileUrl,
                        ossKey: msg.fileData?.ossKey || '',
                        size: msg.fileData?.fileSize || msg.fileSize,
                        timestamp: msg.timestamp,
                        sender: msg.senderName,
                        type: 'shared'
                    });
                }
            });

        }

        // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        function displayFileList(filter) {
            const container = document.getElementById('file-list-container');
            let files = [];

            if (filter === 'ai') {
                files = aiGeneratedFiles;
            } else if (filter === 'shared') {
                files = sharedFiles;
            } else {
                files = [...aiGeneratedFiles, ...sharedFiles];
            }

            // æŒ‰æ—¶é—´å€’åºæ’åº
            files.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            if (files.length === 0) {
                container.innerHTML = `
                    <div style="color: #fff; text-align: center; padding: 20px;">
                        ${filter === 'ai' ? 'æš‚æ— AIç”Ÿæˆçš„æ–‡ä»¶' :
                          filter === 'shared' ? 'æš‚æ— å…±äº«æ–‡ä»¶' :
                          'æš‚æ— æ–‡ä»¶ï¼Œä½¿ç”¨AIç”Ÿæˆæ–‡ä»¶æˆ–ä¸Šä¼ æ–‡ä»¶åå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ'}
                    </div>
                `;
                return;
            }

            // ä¸ºæ–‡ä»¶åˆ—è¡¨ä¸­çš„æ¯ä¸ªæ–‡ä»¶ç”Ÿæˆå”¯ä¸€ID
            files.forEach((file, index) => {
                file.downloadId = 'file-dl-' + Date.now() + '-' + index;
                pendingFileDownloads.set(file.downloadId, {
                    url: file.url,
                    filename: file.filename,
                    ossKey: file.ossKey || ''
                });
            });

            container.innerHTML = files.map(file => `
                <div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 32px;">
                        ${getFileIconByName(file.filename)}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: bold; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${escapeHtml(file.filename)}
                        </div>
                        <div style="font-size: 12px; color: #fff; margin-top: 4px;">
                            ${file.type === 'ai' ? 'ğŸ¤– AIç”Ÿæˆ' : 'ğŸ“ å…±äº«æ–‡ä»¶'} Â·
                            ${file.sender} Â·
                            ${new Date(file.timestamp).toLocaleString()}
                            ${file.size ? ' Â· ' + formatFileSize(file.size) : ''}
                        </div>
                    </div>
                    <button data-download-id="${file.downloadId}" class="file-download-btn"
                            style="background: #666; color: #000; padding: 8px 16px; border-radius: 6px; border: none; font-size: 13px; font-weight: bold; white-space: nowrap; cursor: pointer;">
                        â¬‡ï¸ ä¸‹è½½
                    </button>
                </div>
            `).join('');
        }

        // æ ¹æ®æ–‡ä»¶åè·å–å›¾æ ‡
        function getFileIconByName(filename) {
            const ext = filename.split('.').pop()?.toLowerCase();
            const icons = {
                'md': 'ğŸ“',
                'txt': 'ğŸ“„',
                'json': 'ğŸ“‹',
                'js': 'ğŸ“œ',
                'ts': 'ğŸ“˜',
                'html': 'ğŸŒ',
                'css': 'ğŸ¨',
                'py': 'ğŸ',
                'java': 'â˜•',
                'go': 'ğŸ”µ',
                'rs': 'ğŸ¦€',
                'pdf': 'ğŸ“•',
                'doc': 'ğŸ“˜',
                'docx': 'ğŸ“˜',
                'xls': 'ğŸ“—',
                'xlsx': 'ğŸ“—',
                'ppt': 'ğŸ“™',
                'pptx': 'ğŸ“™',
                'zip': 'ğŸ“¦',
                'rar': 'ğŸ“¦',
                '7z': 'ğŸ“¦',
                'jpg': 'ğŸ–¼ï¸',
                'jpeg': 'ğŸ–¼ï¸',
                'png': 'ğŸ–¼ï¸',
                'gif': 'ğŸ–¼ï¸',
                'mp4': 'ğŸ¬',
                'mp3': 'ğŸµ',
                'wav': 'ğŸµ'
            };
            return icons[ext] || 'ğŸ“„';
        }

        // HTMLè½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // å¤„ç†ä¸‹è½½URLåˆ·æ–°å“åº”
        async function handleDownloadUrlRefreshed(data) {
            const { requestId, downloadUrl } = data;
            const pendingRequest = pendingDownloadRequests.get(requestId);

            if (pendingRequest) {
                // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
                if (pendingRequest.timeoutId) {
                    clearTimeout(pendingRequest.timeoutId);
                }

                // æ‰§è¡Œä¸‹è½½
                if (downloadUrl) {
                    try {
                        await downloadFile(downloadUrl, pendingRequest.filename);
                    } catch (error) {
                        console.error('[Download] Failed after URL refresh:', error);
                        addSystemMessage(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
                    }
                }

                // ä»å¾…å¤„ç†åˆ—è¡¨ä¸­ç§»é™¤
                pendingDownloadRequests.delete(requestId);
            }
        }

        // å¤„ç†æ–‡ä»¶ä¸‹è½½
        async function handleFileDownload(url, filename, ossKey) {

            try {
                // æœ¬åœ°æ–‡ä»¶ç›´æ¥ä¸‹è½½
                if (url.startsWith('/downloads/')) {
                    await downloadFile(url, filename);
                    return;
                }

                // OSSæ–‡ä»¶ï¼šæ£€æŸ¥URLæ˜¯å¦å·²è¿‡æœŸ
                try {
                    const urlObj = new URL(url);
                    const expires = urlObj.searchParams.get('Expires');
                    const now = Math.floor(Date.now() / 1000);

                    if (expires && parseInt(expires) < now) {
                        // URLå·²è¿‡æœŸï¼Œéœ€è¦åˆ·æ–°
                        await refreshAndDownload(url, filename, ossKey);
                    } else {
                        // URLæœªè¿‡æœŸï¼Œå°è¯•ç›´æ¥ä¸‹è½½
                        await downloadFile(url, filename);
                    }
                } catch (urlError) {
                    // URLæ ¼å¼é”™è¯¯æˆ–æ— æ³•è§£æï¼Œå°è¯•ç›´æ¥ä¸‹è½½æˆ–åˆ·æ–°
                    if (ossKey) {
                        await refreshAndDownload(url, filename, ossKey);
                    } else {
                        await downloadFile(url, filename);
                    }
                }
            } catch (error) {
                console.error('[Download] handleFileDownload error:', error);
                log(`ä¸‹è½½å¤±è´¥: ${error.message}`);
                addSystemMessage(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // è¯·æ±‚åˆ·æ–°URLå¹¶ä¸‹è½½
        async function refreshAndDownload(url, filename, ossKey) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('WebSocketæœªè¿æ¥ï¼Œæ— æ³•åˆ·æ–°ä¸‹è½½é“¾æ¥');
                addSystemMessage('æ— æ³•ä¸‹è½½æ–‡ä»¶ï¼šè¿æ¥å·²æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡è¯•', 'error');
                return;
            }

            const requestId = 'dl_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            // å­˜å‚¨å¾…å¤„ç†è¯·æ±‚
            const timeoutId = setTimeout(() => {
                pendingDownloadRequests.delete(requestId);
                log('ä¸‹è½½URLåˆ·æ–°è¶…æ—¶');
                addSystemMessage('æ–‡ä»¶ä¸‹è½½å¤±è´¥ï¼šè¯·æ±‚è¶…æ—¶', 'error');
            }, 10000);

            pendingDownloadRequests.set(requestId, {
                filename,
                url,
                timeoutId
            });

            // å‘é€åˆ·æ–°è¯·æ±‚
            ws.send(JSON.stringify({
                type: 'refresh_download_url',
                ossKey: ossKey || url,
                requestId
            }));
        }

        // æ‰§è¡Œæ–‡ä»¶ä¸‹è½½
        async function downloadFile(url, filename) {
            log(`å¼€å§‹ä¸‹è½½: ${filename}`);

            // æœ¬åœ°æ–‡ä»¶ä½¿ç”¨fetchä¸‹è½½ï¼ˆé¿å…HTTPSé¡µé¢çš„æ··åˆå†…å®¹é—®é¢˜ï¼‰
            if (url.startsWith('/')) {
                log(`æ­£åœ¨ä¸‹è½½æœ¬åœ°æ–‡ä»¶...`);

                try {
                    const response = await fetch(url);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const blob = await response.blob();

                    const blobUrl = window.URL.createObjectURL(blob);
                    const decodedFilename = decodeURIComponent(filename || 'download');

                    const a = document.createElement('a');
                    a.href = blobUrl;
                    a.download = decodedFilename;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();

                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(blobUrl);
                    }, 100);

                    log(`ä¸‹è½½å®Œæˆ: ${decodedFilename}`);
                } catch (error) {
                    console.error('[Download] Local file download failed:', error);
                    log(`ä¸‹è½½å¤±è´¥: ${error.message}`);
                    throw error;
                }
                return;
            }

            // OSSæ–‡ä»¶ï¼šå°†HTTPè½¬æ¢ä¸ºHTTPSï¼ˆè§£å†³æ··åˆå†…å®¹é—®é¢˜ï¼‰
            if (url.startsWith('http://')) {
                url = url.replace('http://', 'https://');
            }

            // OSSæ–‡ä»¶ä½¿ç”¨fetchä¸‹è½½ï¼ˆå¤„ç†è·¨åŸŸï¼‰
            try {
                log('æ­£åœ¨è·å–æ–‡ä»¶...');

                const response = await fetch(url, {
                    method: 'GET',
                    mode: 'cors',
                    credentials: 'omit'
                });


                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();

                if (blob.size === 0) {
                    throw new Error('ä¸‹è½½çš„æ–‡ä»¶ä¸ºç©º');
                }

                const blobUrl = window.URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename || 'download';
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // é‡Šæ”¾blob URL
                setTimeout(() => window.URL.revokeObjectURL(blobUrl), 60000);

                log(`ä¸‹è½½å®Œæˆ: ${filename}`);
            } catch (error) {
                console.error('[Download] Failed:', error);
                log(`ä¸‹è½½å¤±è´¥: ${error.message}`);

                // å¦‚æœfetchå¤±è´¥ï¼ˆå¦‚CORSé”™è¯¯æˆ–ç½‘ç»œé—®é¢˜ï¼‰ï¼Œå°è¯•ç›´æ¥æ‰“å¼€
                if (error.name === 'TypeError' || error.message.includes('Failed to fetch')) {
                    log('å°è¯•åœ¨æ–°çª—å£æ‰“å¼€æ–‡ä»¶...');
                    addSystemMessage('è‡ªåŠ¨ä¸‹è½½å¤±è´¥ï¼Œæ­£åœ¨å°è¯•åœ¨æ–°çª—å£æ‰“å¼€æ–‡ä»¶...', 'warning');
                    window.open(url, '_blank');
                } else {
                    throw error;
                }
            }
        }

        // ç­‰å¾…æœåŠ¡å™¨è¿”å›å¸¦ OSS URL çš„æ¶ˆæ¯
        function waitForUploadUrl(fileId) {
            return new Promise((resolve) => {
                let checkCount = 0;

                const checkInterval = setInterval(() => {
                    checkCount++;
                    const messages = document.querySelectorAll('.message');

                    for (let msg of messages) {
                        const dataAttr = msg.getAttribute('data-file-id');
                        const urlAttr = msg.getAttribute('data-oss-url');

                        if (dataAttr === fileId) {
                            if (urlAttr) {
                                clearInterval(checkInterval);
                                resolve(urlAttr);
                                return;
                            }
                        }
                    }
                }, 500);

                setTimeout(() => {
                    clearInterval(checkInterval);
                    resolve(null);
                }, 10000);
            });
        }

        // å‘é€æ–‡ä»¶ä¸Šä¼ å®Œæˆæ¶ˆæ¯
        function sendFileUploadedMessage(fileId, fileName, fileSize, mimeType) {
            const message = {
                type: 'message',
                message: {
                    id: 'msg-' + Date.now(),
                    type: 'text',
                    content: `æ–‡ä»¶ä¸Šä¼ å®Œæˆ: ${getFileIcon(mimeType)} ${fileName} (${formatFileSize(fileSize)})`,
                    mentions: [],
                    mentionsAI: false
                }
            };

            ws.send(JSON.stringify(message));
        }

        // å–æ¶ˆä¸Šä¼ 
        function cancelUpload() {
            if (currentUpload) {
                currentUpload.abort();
                currentUpload = null;
                log('ä¸Šä¼ å·²å–æ¶ˆ');

                const progressDiv = document.getElementById('upload-progress');
                const progressBar = document.getElementById('upload-bar');
                progressDiv.style.display = 'none';
                progressBar.style.width = '0%';
            }
        }

        // æ¸…ç©ºèŠå¤©
        function clearChat() {
            document.getElementById('chat-container').innerHTML = `
                <div class="load-more-container" id="load-more-container" style="display: none;">
                    <button class="load-more-btn" id="load-more-btn" onclick="loadMoreHistory()">
                        åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
                    </button>
                </div>
            `;
            // æ¸…ç©ºä¾§è¾¹æ 
            document.getElementById('mentions-list').innerHTML = '<div class="sidebar-empty">æš‚æ— @æåŠæ¶ˆæ¯</div>';
            document.getElementById('ai-responses-list').innerHTML = '<div class="sidebar-empty">æš‚æ— AIå›å¤</div>';
            chatHistory = [];
            oldestMessageTime = null;
            hasMoreHistory = true;
            initialHistoryLoaded = false;
        }

        // ===========================================================================
        // AI ä»»åŠ¡è¿›åº¦åŠŸèƒ½
        // ===========================================================================

        // å½“å‰ä»»åŠ¡è®¡åˆ’
        let currentTaskPlan = null;

        // å¤„ç† AI ä»»åŠ¡è®¡åˆ’
        function handleAITaskPlan(payload) {
            if (!payload) return;

            const { planId, title, tasks } = payload;

            currentTaskPlan = {
                planId,
                title,
                tasks: tasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    description: t.description || '',
                    status: 'pending',
                    result: null,
                    error: null
                }))
            };

            renderTaskProgress();
            log(`AI åˆ›å»ºä»»åŠ¡è®¡åˆ’: ${title} (${tasks.length} ä¸ªæ­¥éª¤)`);

            // æ˜¾ç¤ºä»»åŠ¡è¿›åº¦å®¹å™¨
            document.getElementById('task-progress-container').classList.remove('hidden');
        }

        // å¤„ç† AI ä»»åŠ¡æ›´æ–°
        function handleAITaskUpdate(payload) {
            if (!payload || !currentTaskPlan) return;

            const { taskId, status, result, error } = payload;

            // æ›´æ–°ä»»åŠ¡çŠ¶æ€
            const task = currentTaskPlan.tasks.find(t => t.id === taskId);
            if (task) {
                task.status = status;
                if (result) task.result = result;
                if (error) task.error = error;
            }

            renderTaskProgress();
            log(`AI ä»»åŠ¡æ›´æ–°: ${taskId} -> ${status}`);

            // å¦‚æœæ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†ï¼Œ5ç§’åéšè—è¿›åº¦æ¡
            const allCompleted = currentTaskPlan.tasks.every(
                t => t.status === 'completed' || t.status === 'failed' || t.status === 'skipped'
            );
            if (allCompleted) {
                setTimeout(() => {
                    // å¯ä»¥é€‰æ‹©éšè—æˆ–ä¿ç•™æ˜¾ç¤º
                    // document.getElementById('task-progress-container').classList.add('hidden');
                }, 5000);
            }
        }

        // æ¸²æŸ“ä»»åŠ¡è¿›åº¦
        function renderTaskProgress() {
            if (!currentTaskPlan) return;

            const container = document.getElementById('task-progress-container');
            const titleEl = document.getElementById('task-progress-title-text');
            const percentEl = document.getElementById('task-progress-percent');
            const barEl = document.getElementById('task-progress-bar');
            const contentEl = document.getElementById('task-progress-content');

            // æ›´æ–°æ ‡é¢˜
            titleEl.textContent = currentTaskPlan.title;

            // è®¡ç®—è¿›åº¦
            const completedTasks = currentTaskPlan.tasks.filter(
                t => t.status === 'completed' || t.status === 'failed' || t.status === 'skipped'
            ).length;
            const totalTasks = currentTaskPlan.tasks.length;
            const percent = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

            percentEl.textContent = `${percent}%`;
            barEl.style.width = `${percent}%`;

            // æ ¹æ®è¿›åº¦æ›´æ–°é¢œè‰²
            const allCompleted = currentTaskPlan.tasks.every(t => t.status === 'completed');
            const hasFailed = currentTaskPlan.tasks.some(t => t.status === 'failed');
            if (allCompleted) {
                barEl.style.background = '#4caf50';
            } else if (hasFailed) {
                barEl.style.background = '#f44336';
            } else {
                barEl.style.background = '#666';
            }

            // æ¸²æŸ“ä»»åŠ¡åˆ—è¡¨
            contentEl.innerHTML = currentTaskPlan.tasks.map(task => {
                const statusIcon = getTaskStatusIcon(task.status);
                const statusClass = `task-status-${task.status}`;

                return `
                    <div class="task-item">
                        <div class="task-status-icon ${statusClass}">${statusIcon}</div>
                        <div class="task-info">
                            <div class="task-title">${escapeHtml(task.title)}</div>
                            ${task.description ? `<div class="task-description">${escapeHtml(task.description)}</div>` : ''}
                            ${task.result ? `<div class="task-result">${escapeHtml(task.result)}</div>` : ''}
                            ${task.error ? `<div class="task-error">âŒ ${escapeHtml(task.error)}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // è·å–ä»»åŠ¡çŠ¶æ€å›¾æ ‡
        function getTaskStatusIcon(status) {
            switch (status) {
                case 'pending': return 'â³';
                case 'in_progress': return 'ğŸ”„';
                case 'completed': return 'âœ…';
                case 'failed': return 'âŒ';
                case 'skipped': return 'â­ï¸';
                default: return 'ğŸ“Œ';
            }
        }

        // HTML è½¬ä¹‰
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åˆ‡æ¢ä»»åŠ¡è¿›åº¦æ˜¾ç¤º
        function toggleTaskProgress() {
            const content = document.getElementById('task-progress-content');
            const toggle = document.getElementById('task-progress-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                toggle.textContent = 'â–²';
            }
        }

        // åˆ‡æ¢èŠå¤©å®¤å…¨å±æ¨¡å¼
        function toggleChatFullscreen() {
            const chatCard = document.getElementById('chat-card');
            const isFullscreen = chatCard.classList.contains('fullscreen-mode');

            if (isFullscreen) {
                // é€€å‡ºå…¨å±
                chatCard.classList.remove('fullscreen-mode');
                document.body.style.overflow = '';
            } else {
                // è¿›å…¥å…¨å±
                chatCard.classList.add('fullscreen-mode');
                document.body.style.overflow = 'hidden';
            }
        }

        // åˆ‡æ¢è¯­éŸ³AIå…¨å±æ¨¡å¼
        function toggleVoiceAIFullscreen() {
            const voiceAIPanel = document.getElementById('voice-ai-panel');
            const isFullscreen = voiceAIPanel.classList.contains('fullscreen-mode');

            if (isFullscreen) {
                // é€€å‡ºå…¨å±
                voiceAIPanel.classList.remove('fullscreen-mode');
            } else {
                // è¿›å…¥å…¨å±
                voiceAIPanel.classList.add('fullscreen-mode');
            }
        }

        // åˆ‡æ¢èŠå¤©å®¤æŠ˜å çŠ¶æ€
        function toggleChatCollapse() {
            const chatCard = document.getElementById('chat-card');
            const collapseBtn = document.getElementById('chat-collapse-btn');
            const isCollapsed = chatCard.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                chatCard.classList.remove('collapsed');
                collapseBtn.textContent = 'â–¼';
            } else {
                // æŠ˜å 
                chatCard.classList.add('collapsed');
                collapseBtn.textContent = 'â–¶';
            }
        }

        // åˆ‡æ¢è¯­éŸ³AIæŠ˜å çŠ¶æ€
        function toggleVoiceAICollapse() {
            const voiceAIPanel = document.getElementById('voice-ai-panel');
            const collapseBtn = document.getElementById('voice-ai-collapse-btn');
            const isCollapsed = voiceAIPanel.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                voiceAIPanel.classList.remove('collapsed');
                collapseBtn.textContent = 'â–¼';
            } else {
                // æŠ˜å 
                voiceAIPanel.classList.add('collapsed');
                collapseBtn.textContent = 'â–¶';
            }
        }

        // åˆ‡æ¢å…±äº«AIæŠ˜å çŠ¶æ€
        function toggleSharedAICollapse() {
            const sharedAIPanel = document.getElementById('shared-ai-panel');
            const collapseBtn = document.getElementById('shared-ai-collapse-btn');
            const isCollapsed = sharedAIPanel.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                sharedAIPanel.classList.remove('collapsed');
                collapseBtn.textContent = 'â–¼';
            } else {
                // æŠ˜å 
                sharedAIPanel.classList.add('collapsed');
                collapseBtn.textContent = 'â–¶';
            }
        }

        // åˆ‡æ¢å…±äº«AIå…¨å±æ¨¡å¼
        function toggleSharedAIFullscreen() {
            const sharedAIPanel = document.getElementById('shared-ai-panel');
            const isFullscreen = sharedAIPanel.classList.contains('fullscreen-mode');

            if (isFullscreen) {
                // é€€å‡ºå…¨å±
                sharedAIPanel.classList.remove('fullscreen-mode');
            } else {
                // è¿›å…¥å…¨å±
                sharedAIPanel.classList.add('fullscreen-mode');
            }
        }

        // ä¿å­˜å…±äº«AIèŠå¤©è®°å½•
        function saveSharedAIChat() {
            if (!sharedAI.chatMessages || sharedAI.chatMessages.length === 0) {
                alert('æ²¡æœ‰èŠå¤©è®°å½•å¯ä¿å­˜');
                return;
            }

            const content = sharedAI.chatMessages.map(msg => {
                const time = msg.timestamp ? new Date(msg.timestamp).toLocaleString() : '';
                return `[${time}] ${msg.senderName}: ${msg.content}`;
            }).join('\n');

            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shared-ai-chat-${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ¸…ç©ºå…±äº«AIèŠå¤©è®°å½•
        function clearSharedAIChat() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºèŠå¤©è®°å½•å—ï¼Ÿ')) return;
            sharedAI.chatMessages = [];
            const chatArea = document.getElementById('shared-ai-chat-area');
            if (chatArea) {
                chatArea.innerHTML = '';
            }
        }

        // ===========================================================================
        // å…±äº«AIä¸Šä¸‹æ–‡æ–‡ä»¶ç®¡ç†
        // ===========================================================================

        const MAX_SHARED_CONTEXT_FILES = 5;

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        async function handleSharedAIFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆæœ€å¤§ 1MBï¼‰
            if (file.size > 1024 * 1024) {
                alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 1MB');
                event.target.value = '';
                return;
            }

            if (sharedAIContextFiles.length >= MAX_SHARED_CONTEXT_FILES) {
                alert(`ä¸Šä¸‹æ–‡æ–‡ä»¶æ•°é‡å·²è¾¾ä¸Šé™ (${MAX_SHARED_CONTEXT_FILES} ä¸ª)ï¼Œè¯·å…ˆåˆ é™¤éƒ¨åˆ†æ–‡ä»¶`);
                event.target.value = '';
                return;
            }

            try {
                const content = await readFileAsText(file);

                // å¦‚æœæ­£åœ¨å…±äº«AIä¼šè¯ä¸­ï¼Œå®æ—¶å‘é€ç»™AI
                if (sharedAI.isActive && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'shared_ai_add_context',
                        context: content,
                        contextType: 'text',
                        fileName: file.name
                    }));

                    // åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°åˆ—è¡¨
                    sharedAIContextFiles.push({
                        name: file.name,
                        content: content,
                        type: 'text'
                    });
                    saveSharedAIContextFiles();
                    renderSharedAIContextFiles();

                    log(`[SharedAI] æ–‡ä»¶å·²å‘é€ç»™AI: ${file.name}`);
                } else {
                    // æœªåœ¨ä¼šè¯ä¸­ï¼Œä»…ä¿å­˜åˆ°æœ¬åœ°
                    sharedAIContextFiles.push({
                        name: file.name,
                        content: content,
                        type: 'text'
                    });
                    saveSharedAIContextFiles();
                    renderSharedAIContextFiles();
                    log(`[SharedAI] Added context file: ${file.name}`);
                }
            } catch (error) {
                console.error('[SharedAI] Failed to read file:', error);
                alert('è¯»å–æ–‡ä»¶å¤±è´¥: ' + error.message);
            }

            event.target.value = '';
        }

        // æ·»åŠ ç²˜è´´çš„æ–‡æœ¬
        function addSharedAIPastedText() {
            const filenameInput = document.getElementById('shared-ai-paste-filename');
            const contentInput = document.getElementById('shared-ai-paste-content');

            const content = contentInput.value.trim();
            if (!content) {
                alert('è¯·è¾“å…¥æ–‡æœ¬å†…å®¹');
                return;
            }

            if (sharedAIContextFiles.length >= MAX_SHARED_CONTEXT_FILES) {
                alert(`ä¸Šä¸‹æ–‡æ–‡ä»¶æ•°é‡å·²è¾¾ä¸Šé™ (${MAX_SHARED_CONTEXT_FILES} ä¸ª)ï¼Œè¯·å…ˆåˆ é™¤éƒ¨åˆ†æ–‡ä»¶`);
                return;
            }

            // é™åˆ¶æ–‡æœ¬é•¿åº¦ï¼ˆæœ€å¤§ 500KBï¼‰
            if (content.length > 500 * 1024) {
                alert('æ–‡æœ¬å†…å®¹è¿‡é•¿ï¼Œè¯·ç¼©çŸ­åé‡è¯•');
                return;
            }

            // ç”Ÿæˆæ–‡ä»¶å
            let fileName = filenameInput.value.trim();
            if (!fileName) {
                fileName = `pasted_text_${new Date().toISOString().slice(0, 10)}.txt`;
            }
            // ç¡®ä¿æ–‡ä»¶åæœ‰æ‰©å±•å
            if (!fileName.includes('.')) {
                fileName += '.txt';
            }

            // å¦‚æœæ­£åœ¨å…±äº«AIä¼šè¯ä¸­ï¼Œå®æ—¶å‘é€ç»™AI
            if (sharedAI.isActive && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'shared_ai_add_context',
                    context: content,
                    contextType: 'text',
                    fileName: fileName
                }));

                // åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°åˆ—è¡¨
                sharedAIContextFiles.push({
                    name: fileName,
                    content: content,
                    type: 'text'
                });
                saveSharedAIContextFiles();
                renderSharedAIContextFiles();

                log(`[SharedAI] æ–‡æœ¬å·²å‘é€ç»™AIï¼Œç­‰å¾…å›å¤...`);
            } else {
                // æœªåœ¨ä¼šè¯ä¸­ï¼Œä»…ä¿å­˜åˆ°æœ¬åœ°
                sharedAIContextFiles.push({
                    name: fileName,
                    content: content,
                    type: 'text'
                });

                saveSharedAIContextFiles();
                renderSharedAIContextFiles();

                log(`[SharedAI] Added pasted text: ${fileName}`);
            }

            // æ¸…ç©ºè¾“å…¥
            filenameInput.value = '';
            contentInput.value = '';
        }

        // åˆ é™¤ä¸Šä¸‹æ–‡æ–‡ä»¶
        function removeSharedAIContextFile(index) {
            if (index >= 0 && index < sharedAIContextFiles.length) {
                const file = sharedAIContextFiles[index];
                sharedAIContextFiles.splice(index, 1);
                saveSharedAIContextFiles();
                renderSharedAIContextFiles();
                log(`[SharedAI] Removed context file: ${file.name}`);
            }
        }

        // ä¿å­˜ä¸Šä¸‹æ–‡æ–‡ä»¶åˆ° localStorage
        function saveSharedAIContextFiles() {
            try {
                localStorage.setItem('sharedAI_contextFiles', JSON.stringify(sharedAIContextFiles));
            } catch (e) {
                console.error('[SharedAI] Failed to save context files:', e);
            }
        }

        // åŠ è½½ä¸Šä¸‹æ–‡æ–‡ä»¶
        function loadSharedAIContextFiles() {
            try {
                const savedFiles = localStorage.getItem('sharedAI_contextFiles');
                if (savedFiles) {
                    sharedAIContextFiles = JSON.parse(savedFiles);
                    renderSharedAIContextFiles();
                }
            } catch (e) {
                console.error('[SharedAI] Failed to load context files:', e);
            }
        }

        // æ¸²æŸ“ä¸Šä¸‹æ–‡æ–‡ä»¶åˆ—è¡¨
        function renderSharedAIContextFiles() {
            const container = document.getElementById('shared-ai-context-files');
            if (!container) return;

            if (sharedAIContextFiles.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 8px;">';
            html += '<div style="font-size: 12px; color: #aaa; margin-bottom: 8px;">ğŸ“ ä¸Šä¸‹æ–‡æ–‡ä»¶ (' + sharedAIContextFiles.length + '/' + MAX_SHARED_CONTEXT_FILES + ')</div>';

            sharedAIContextFiles.forEach((file, index) => {
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: #333; border-radius: 4px; margin-bottom: 4px;">
                        <span style="font-size: 12px; color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;">${escapeHtml(file.name)}</span>
                        <button onclick="removeSharedAIContextFile(${index})" style="background: #dc3545; border: none; color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">ç§»é™¤</button>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // åˆ‡æ¢è°ƒè¯•æ—¥å¿—æŠ˜å çŠ¶æ€
        function toggleLogCollapse() {
            const logCard = document.getElementById('log-card');
            const collapseBtn = document.getElementById('log-collapse-btn');
            const isCollapsed = logCard.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                logCard.classList.remove('collapsed');
                collapseBtn.textContent = 'â–¼';
            } else {
                // æŠ˜å 
                logCard.classList.add('collapsed');
                collapseBtn.textContent = 'â–¶';
            }
        }

        // å¤åˆ¶èŠå¤©å®¤èŠå¤©è®°å½•
        async function copyChatHistory() {
            const container = document.getElementById('chat-container');
            const messages = container.querySelectorAll('.message');

            if (messages.length === 0) {
                alert('æš‚æ— èŠå¤©è®°å½•å¯å¤åˆ¶');
                return;
            }

            let text = '';
            messages.forEach(msg => {
                const header = msg.querySelector('.message-header');
                const content = msg.querySelector('.message-content');
                if (header && content) {
                    const sender = header.textContent.trim();
                    const messageText = content.textContent.trim();
                    text += `[${sender}] ${messageText}\n`;
                }
            });

            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(document.querySelector('#chat-card .copy-btn'));
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                // é™çº§æ–¹æ¡ˆ
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showCopyFeedback(document.querySelector('#chat-card .copy-btn'));
            }
        }

        // å¤åˆ¶è¯­éŸ³AIå¯¹è¯è®°å½•
        async function copyVoiceAIChat() {
            if (voiceAIChatHistory.length === 0) {
                alert('æš‚æ— å¯¹è¯è®°å½•å¯å¤åˆ¶');
                return;
            }

            let text = '# è¯­éŸ³AIå¯¹è¯è®°å½•\n\n';
            voiceAIChatHistory.forEach(msg => {
                const role = msg.role === 'user' ? 'ç”¨æˆ·' : 'AI';
                const time = new Date(msg.timestamp).toLocaleString('zh-CN');
                text += `## ${role} (${time})\n\n${msg.text}\n\n`;
            });

            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(document.querySelector('#voice-ai-chat-area .copy-btn'));
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showCopyFeedback(document.querySelector('#voice-ai-chat-area .copy-btn'));
            }
        }

        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸåé¦ˆ
        function showCopyFeedback(btn) {
            if (!btn) return;
            const originalText = btn.textContent;
            btn.textContent = 'âœ“ å·²å¤åˆ¶';
            btn.classList.add('copied');
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('copied');
            }, 2000);
        }

        // é¡µé¢åŠ è½½å®Œæˆ
        window.onload = () => {
            log('é¡µé¢åŠ è½½å®Œæˆ');

            // åˆå§‹åŒ–è¯­éŸ³AIä¸Šä¸‹æ–‡æ–‡ä»¶åˆ—è¡¨
            loadVoiceAIChatFromLocalStorage();

            // è®¾ç½®æ–‡ä»¶ä¸‹è½½äº‹ä»¶å§”æ‰˜
            setupFileDownloadDelegation();

            // è‡ªåŠ¨å¡«å……æœåŠ¡å™¨åœ°å€
            autoFillServerUrl();

            // æ£€æŸ¥ HTTPS
            const isHTTPS = window.location.protocol === 'https:';
            const httpsWarningEl = document.getElementById('voice-https-warning');
            const httpsOkEl = document.getElementById('voice-https-ok');

            if (isHTTPS) {
                log('âœ… å·²ä½¿ç”¨ HTTPSï¼Œè¯­éŸ³åŠŸèƒ½å®Œå…¨å¯ç”¨');
                if (httpsWarningEl) httpsWarningEl.style.display = 'none';
                if (httpsOkEl) httpsOkEl.style.display = 'block';
            } else {
                log('âš ï¸ å½“å‰ä½¿ç”¨ HTTPï¼Œå®‰å“æµè§ˆå™¨å¯èƒ½æ— æ³•ä½¿ç”¨è¯­éŸ³åŠŸèƒ½');
                if (httpsWarningEl) httpsWarningEl.style.display = 'block';
                if (httpsOkEl) httpsOkEl.style.display = 'none';
            }

            // è®°å½•æµè§ˆå™¨ä¿¡æ¯ï¼ˆå·²ç¦ç”¨è¯¦ç»†æ—¥å¿—ï¼‰

            // æ˜¾ç¤ºè¿æ¥æç¤º
            const wsUrl = getDefaultWsUrl();
            log(`è‡ªåŠ¨æ£€æµ‹åˆ°æœåŠ¡å™¨åœ°å€: ${wsUrl}`);
            log(`å½“å‰åè®®: ${window.location.protocol}`);
        };

        // é¡µé¢å¯è§æ€§ç›‘å¬ - å¤„ç†ç§»åŠ¨ç«¯æ¯å±åé‡è¿
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // é¡µé¢æ¢å¤å¯è§æ—¶ï¼Œæ£€æŸ¥è¿æ¥çŠ¶æ€
                log('é¡µé¢æ¢å¤å¯è§');
                if (lastConnectParams && (!ws || ws.readyState !== WebSocket.OPEN)) {
                    log('æ£€æµ‹åˆ°è¿æ¥å·²æ–­å¼€ï¼Œå°è¯•é‡è¿...');
                    if (!isManualDisconnect) {
                        reconnectAttempts = 0;  // é‡ç½®é‡è¿è®¡æ•°
                        reconnect();
                    }
                }
                // é‡æ–°è·å– Wake Lockï¼ˆå¦‚æœæœ‰è¯­éŸ³åŠŸèƒ½åœ¨æ´»è·ƒï¼‰
                handleWakeLockOnVisible();
            } else {
                // é¡µé¢éšè—æ—¶ï¼Œè®°å½•çŠ¶æ€
                log('é¡µé¢è¿›å…¥åå°');
            }
        });

        // é¡µé¢æ¢å¤æ—¶çš„é¢å¤–å¤„ç†ï¼ˆé’ˆå¯¹éƒ¨åˆ†ç§»åŠ¨æµè§ˆå™¨ï¼‰
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                log('é¡µé¢ä» bfcache æ¢å¤');
                if (lastConnectParams && (!ws || ws.readyState !== WebSocket.OPEN)) {
                    if (!isManualDisconnect) {
                        reconnectAttempts = 0;
                        reconnect();
                    }
                }
            }
        });

        // ===========================================================================
        // è¯­éŸ³AIåŠŸèƒ½ - ç«å±±å¼•æ“è±†åŒ…ç«¯åˆ°ç«¯å®æ—¶è¯­éŸ³å¤§æ¨¡å‹
        // ===========================================================================

        let voiceAI = {
            isActive: false,
            isListening: false,
            isSpeaking: false,
            isMuted: false,  // éº¦å…‹é£çŠ¶æ€
            audioContext: null,
            mediaStream: null,
            audioProcessor: null,
            analyser: null,
            currentTranscript: '',
            lastResponse: '',
            playbackQueue: [],
            isPlayingAudio: false,
            // VAD é…ç½®
            vadConfig: {
                energyThreshold: 0.01,
                silenceFrames: 20,
                minSpeechFrames: 5,
                frameSize: 4096,
            },
            vadState: {
                energyHistory: [],
                silenceCount: 0,
                speechCount: 0,
                isSpeech: false,
            },
        };

        // ===========================================================================
        // å…±äº«è¯­éŸ³AIåŠŸèƒ½ - å¤šäººå…±äº«AIå¯¹è¯
        // ===========================================================================

        let sharedAI = {
            enabled: false,
            isActive: false,
            isReady: false,
            isMuted: false,  // éº¦å…‹é£çŠ¶æ€
            state: 'idle',
            currentSpeaker: null,
            pendingResponse: '',
            audioChunks: [],
            participants: [],
            audioContext: null,
            mediaStream: null,
            audioProcessor: null,
            analyser: null,
            currentAudio: null,
            chatMessages: [],  // èŠå¤©è®°å½•
            userColors: {},  // ç”¨æˆ·é¢œè‰²æ˜ å°„
        };

        let sharedAIContextFiles = []; // ç”¨äºå­˜å‚¨ä½œä¸ºå…±äº«AIä¸Šä¸‹æ–‡çš„æ–‡ä»¶

        // åŠ å…¥å…±äº«AIä¼šè¯
        async function joinSharedAI() {
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!isAudioSupported()) {
                let errorMsg = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½ã€‚';
                if (window.location.protocol !== 'https:' && !window.isSecureContext) {
                    errorMsg += '\n\nå®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚';
                }
                alert(errorMsg);
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            try {
                const getUserMedia = getUserMediaFunction();
                if (!getUserMedia) {
                    throw new Error('getUserMedia not available');
                }

                // è¯·æ±‚éº¦å…‹é£æƒé™
                sharedAI.mediaStream = await getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                    }
                });

                // åˆ›å»º AudioContext
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                sharedAI.audioContext = new AudioContextClass({
                    sampleRate: 16000,
                });

                const source = sharedAI.audioContext.createMediaStreamSource(sharedAI.mediaStream);

                // åˆ›å»º ScriptProcessor ç”¨äºéŸ³é¢‘å¤„ç†
                const bufferSize = 4096;
                sharedAI.audioProcessor = sharedAI.audioContext.createScriptProcessor(bufferSize, 1, 1);

                // åˆ›å»º analyser ç”¨äºéŸ³é‡æ£€æµ‹
                sharedAI.analyser = sharedAI.audioContext.createAnalyser();
                sharedAI.analyser.fftSize = 2048;
                source.connect(sharedAI.analyser);

                // VAD ç›¸å…³å˜é‡
                sharedAI.isSpeaking = false;
                sharedAI.silenceCount = 0;
                sharedAI.speechCount = 0;
                const VAD_SPEECH_THRESHOLD = 0.02;  // è¯­éŸ³èƒ½é‡é˜ˆå€¼
                const VAD_SPEECH_FRAMES = 3;        // è¿ç»­å‡ å¸§è¶…è¿‡é˜ˆå€¼æ‰ç®—è¯´è¯
                const VAD_SILENCE_FRAMES = 10;      // è¿ç»­å‡ å¸§ä½äºé˜ˆå€¼æ‰ç®—é™éŸ³

                // éŸ³é¢‘å¤„ç†
                sharedAI.audioProcessor.onaudioprocess = (event) => {
                    if (!sharedAI.isActive || !ws || ws.readyState !== WebSocket.OPEN) return;

                    // é—­éº¦æ—¶ä¸å‘é€éŸ³é¢‘
                    if (sharedAI.isMuted) return;

                    const inputData = event.inputBuffer.getChannelData(0);

                    // ç®€å•çš„VADæ£€æµ‹ï¼šè®¡ç®—éŸ³é¢‘èƒ½é‡
                    let energy = 0;
                    for (let i = 0; i < inputData.length; i++) {
                        energy += inputData[i] * inputData[i];
                    }
                    energy = Math.sqrt(energy / inputData.length);

                    // VADçŠ¶æ€æ›´æ–°
                    if (energy > VAD_SPEECH_THRESHOLD) {
                        sharedAI.speechCount++;
                        sharedAI.silenceCount = 0;
                        if (sharedAI.speechCount >= VAD_SPEECH_FRAMES && !sharedAI.isSpeaking) {
                            sharedAI.isSpeaking = true;
                        }
                    } else {
                        sharedAI.silenceCount++;
                        sharedAI.speechCount = 0;
                        if (sharedAI.silenceCount >= VAD_SILENCE_FRAMES && sharedAI.isSpeaking) {
                            sharedAI.isSpeaking = false;
                        }
                    }

                    // Float32 è½¬ PCM16
                    const pcmData = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        const s = Math.max(-1, Math.min(1, inputData[i]));
                        pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    const base64Audio = arrayBufferToBase64(pcmData.buffer);

                    ws.send(JSON.stringify({
                        type: 'shared_ai_audio',
                        audioData: base64Audio,
                        isSpeaking: sharedAI.isSpeaking
                    }));
                };

                source.connect(sharedAI.audioProcessor);
                // æ³¨æ„ï¼šä¸ç›´æ¥è¿æ¥åˆ° destinationï¼Œé¿å…æœ¬åœ°å›å£°
                // åˆ›å»ºä¸€ä¸ªé™éŸ³çš„å¢ç›ŠèŠ‚ç‚¹
                const silentGain = sharedAI.audioContext.createGain();
                silentGain.gain.value = 0;  // é™éŸ³
                sharedAI.audioProcessor.connect(silentGain);
                silentGain.connect(sharedAI.audioContext.destination);

                // å‘é€åŠ å…¥å…±äº«AIè¯·æ±‚ï¼ˆåŒ…å«ä¸Šä¸‹æ–‡æ–‡ä»¶ï¼‰
                const files = sharedAIContextFiles || [];
                ws.send(JSON.stringify({
                    type: 'shared_ai_join',
                    files: files
                }));


            } catch (error) {
                console.error('[SharedAI] Failed to join:', error);
                alert('åŠ å…¥å…±äº«AIå¤±è´¥: ' + error.message);

                // æ¸…ç†èµ„æº
                if (sharedAI.mediaStream) {
                    sharedAI.mediaStream.getTracks().forEach(track => track.stop());
                    sharedAI.mediaStream = null;
                }
                if (sharedAI.audioProcessor) {
                    sharedAI.audioProcessor.disconnect();
                    sharedAI.audioProcessor = null;
                }
                if (sharedAI.audioContext) {
                    sharedAI.audioContext.close();
                    sharedAI.audioContext = null;
                }
            }
        }

        // ç¦»å¼€å…±äº«AIä¼šè¯
        async function leaveSharedAI() {
            // åœæ­¢éŸ³é¢‘
            if (sharedAI.currentAudio) {
                sharedAI.currentAudio.pause();
                sharedAI.currentAudio = null;
            }

            // æ¸…ç†éŸ³é¢‘èµ„æº
            if (sharedAI.mediaStream) {
                sharedAI.mediaStream.getTracks().forEach(track => track.stop());
                sharedAI.mediaStream = null;
            }
            if (sharedAI.audioProcessor) {
                sharedAI.audioProcessor.disconnect();
                sharedAI.audioProcessor = null;
            }
            if (sharedAI.audioContext) {
                sharedAI.audioContext.close();
                sharedAI.audioContext = null;
            }

            // å‘é€ç¦»å¼€è¯·æ±‚
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'shared_ai_leave'
                }));
            }

            sharedAI.isActive = false;
            sharedAI.isReady = false;
            sharedAI.state = 'idle';
            sharedAI.currentSpeaker = null;
            sharedAI.audioChunks = [];
            sharedAI.participants = [];

            updateSharedAIUI();
            log('[SharedAI] Left shared AI session');
        }

        // åˆ‡æ¢å…±äº«AIéº¦å…‹é£çŠ¶æ€
        function toggleSharedAIMute() {
            sharedAI.isMuted = !sharedAI.isMuted;
            const btn = document.getElementById('btn-shared-ai-mute');
            if (sharedAI.isMuted) {
                btn.textContent = 'ğŸ”‡ é—­éº¦';
                btn.style.background = '#dc3545';
                log('[SharedAI] å·²é—­éº¦');
            } else {
                btn.textContent = 'ğŸ¤ å¼€éº¦';
                btn.style.background = '#28a745';
                log('[SharedAI] å·²å¼€éº¦');
            }
        }

        // å‘é€å…±äº«AIæ–‡æœ¬
        function sendSharedAIText(text) {
            if (!sharedAI.isActive || !ws || ws.readyState !== WebSocket.OPEN) return;

            ws.send(JSON.stringify({
                type: 'shared_ai_text',
                text: text
            }));
        }

        // æ›´æ–°å…±äº«AIçŠ¶æ€æ˜¾ç¤º
        function updateSharedAIState(state, speaker) {
            const dot = document.getElementById('shared-ai-state-dot');
            const text = document.getElementById('shared-ai-state-text');
            const speakerEl = document.getElementById('shared-ai-speaker');

            sharedAI.state = state;

            switch (state) {
                case 'listening':
                    if (dot) dot.style.background = '#888';
                    if (text) text.textContent = 'ç­‰å¾…è¯´è¯...';
                    break;
                case 'speaking':
                    if (dot) dot.style.background = '#666';
                    if (text) text.textContent = 'AIå›å¤ä¸­...';
                    break;
                case 'thinking':
                    if (dot) dot.style.background = '#888';
                    if (text) text.textContent = 'AIæ€è€ƒä¸­...';
                    break;
            }

            // æ›´æ–°è¯´è¯è€…æ˜¾ç¤º
            if (speakerEl) {
                if (speaker) {
                    speakerEl.textContent = `ğŸ¤ ${speaker.userName}`;
                    speakerEl.style.display = 'inline';
                } else {
                    speakerEl.style.display = 'none';
                }
            }

            sharedAI.currentSpeaker = speaker;
        }

        // ç”¨æˆ·é¢œè‰²åˆ—è¡¨
        const USER_COLORS = [
            '#4CAF50', '#2196F3', '#FF9800', '#E91E63', '#9C27B0',
            '#00BCD4', '#FF5722', '#607D8B', '#795548', '#3F51B5'
        ];

        // è·å–èŠå¤©å®¤ç”¨æˆ·é¢œè‰²
        function getChatUserColor(userId) {
            if (!chatUserColors[userId]) {
                const colorIndex = Object.keys(chatUserColors).length % USER_COLORS.length;
                chatUserColors[userId] = USER_COLORS[colorIndex];
            }
            return chatUserColors[userId];
        }

        // è·å–ç”¨æˆ·é¢œè‰²
        function getSharedAIUserColor(userId) {
            if (!sharedAI.userColors[userId]) {
                const colorIndex = Object.keys(sharedAI.userColors).length % USER_COLORS.length;
                sharedAI.userColors[userId] = USER_COLORS[colorIndex];
            }
            return sharedAI.userColors[userId];
        }

        // æ·»åŠ å…±äº«AIèŠå¤©æ¶ˆæ¯
        function addSharedAIChatMessage(type, name, text, userId) {
            const chatMessages = document.getElementById('shared-ai-chat-messages');
            if (!chatMessages) return;

            // æ¸…é™¤åˆå§‹æç¤º
            if (sharedAI.chatMessages.length === 0) {
                chatMessages.innerHTML = '';
            }

            const message = {
                type: type,
                name: name,
                text: text,
                userId: userId,
                timestamp: new Date().toISOString()
            };
            sharedAI.chatMessages.push(message);

            // é™åˆ¶èŠå¤©è®°å½•å¤§å°
            if (sharedAI.chatMessages.length > MAX_CHAT_HISTORY) {
                sharedAI.chatMessages = sharedAI.chatMessages.slice(-MAX_CHAT_HISTORY);
                // åŒæ—¶ç§»é™¤å¯¹åº”çš„DOMå…ƒç´ 
                while (chatMessages.children.length > MAX_CHAT_HISTORY) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }

            // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
            const msgDiv = document.createElement('div');
            msgDiv.style.cssText = 'padding: 8px 12px; border-radius: 8px; font-size: 14px; line-height: 1.5;';

            if (type === 'ai') {
                // AI æ¶ˆæ¯ - ç»¿è‰²èƒŒæ™¯
                msgDiv.style.background = 'rgba(76, 175, 80, 0.2)';
                msgDiv.style.borderLeft = '3px solid #4CAF50';
                msgDiv.innerHTML = `<strong style="color: #4CAF50;">ğŸ¤– ${escapeHtml(name)}:</strong><br><span style="color: #fff;">${markdownToHtml(text)}</span>`;
            } else {
                // ç”¨æˆ·æ¶ˆæ¯ - æ ¹æ®ç”¨æˆ·IDåˆ†é…é¢œè‰²
                const userColor = getSharedAIUserColor(userId);
                msgDiv.style.background = `rgba(${hexToRgb(userColor)}, 0.15)`;
                msgDiv.style.borderLeft = `3px solid ${userColor}`;
                msgDiv.innerHTML = `<strong style="color: ${userColor};">ğŸ‘¤ ${escapeHtml(name)}:</strong> <span style="color: #fff;">${escapeHtml(text)}</span>`;
            }

            chatMessages.appendChild(msgDiv);

            // æ»šåŠ¨åˆ°åº•éƒ¨
            const chatArea = document.getElementById('shared-ai-chat-area');
            if (chatArea) {
                chatArea.scrollTop = chatArea.scrollHeight;
            }

            // é™åˆ¶æ¶ˆæ¯æ•°é‡
            while (sharedAI.chatMessages.length > 100) {
                sharedAI.chatMessages.shift();
                if (chatMessages.firstChild) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šåå…­è¿›åˆ¶é¢œè‰²è½¬RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` :
                '255, 255, 255';
        }

        // å¤åˆ¶å…±äº«AIèŠå¤©è®°å½•
        function copySharedAIChat(e) {
            if (sharedAI.chatMessages.length === 0) {
                alert('æš‚æ— èŠå¤©è®°å½•å¯å¤åˆ¶');
                return;
            }

            const text = sharedAI.chatMessages.map(msg => {
                const time = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                return `[${time}] ${msg.name}: ${msg.text}`;
            }).join('\n');

            navigator.clipboard.writeText(text).then(() => {
                log('[SharedAI] èŠå¤©è®°å½•å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                const btn = e.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… å·²å¤åˆ¶';
                btn.style.background = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 1500);
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶');
            });
        }

        // å¯¼å‡ºå…±äº«AIèŠå¤©è®°å½•
        function exportSharedAIChat() {
            if (sharedAI.chatMessages.length === 0) {
                alert('æš‚æ— èŠå¤©è®°å½•å¯å¯¼å‡º');
                return;
            }

            // ç”Ÿæˆæ–‡æœ¬å†…å®¹
            const header = `å…±äº«AIå¯¹è¯è®°å½•\nå¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString('zh-CN')}\nå‚ä¸è€…: ${sharedAI.participants.map(p => p.userName).join(', ')}\n${'='.repeat(50)}\n\n`;
            const content = sharedAI.chatMessages.map(msg => {
                const time = new Date(msg.timestamp).toLocaleString('zh-CN');
                return `[${time}] ${msg.name}:\n${msg.text}\n`;
            }).join('\n');

            const fullText = header + content;

            // åˆ›å»ºä¸‹è½½
            const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `å…±äº«AIå¯¹è¯_${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('[SharedAI] èŠå¤©è®°å½•å·²å¯¼å‡º');
        }

        // æ›´æ–°å…±äº«AI UI
        function updateSharedAIUI() {
            const joinBtn = document.getElementById('btn-shared-ai-join');
            const muteBtn = document.getElementById('btn-shared-ai-mute');
            const leaveBtn = document.getElementById('btn-shared-ai-leave');
            const saveBtn = document.getElementById('btn-shared-ai-save');
            const clearBtn = document.getElementById('btn-shared-ai-clear');
            const statusEl = document.getElementById('shared-ai-status');
            const stateDisplay = document.getElementById('shared-ai-state-display');
            const speakerDisplay = document.getElementById('shared-ai-speaker-display');
            const participantsEl = document.getElementById('shared-ai-participants');
            const transcriptArea = document.getElementById('shared-ai-transcript-area');
            const chatArea = document.getElementById('shared-ai-chat-area');
            const responseArea = document.getElementById('shared-ai-response-area');

            if (sharedAI.isActive) {
                if (joinBtn) joinBtn.classList.add('hidden');
                if (muteBtn) muteBtn.classList.remove('hidden');
                if (leaveBtn) leaveBtn.classList.remove('hidden');
                if (saveBtn) saveBtn.style.display = 'inline-block';
                if (clearBtn) clearBtn.style.display = 'inline-block';
                if (statusEl) {
                    statusEl.className = 'status status-connected';
                    statusEl.textContent = 'å·²åŠ å…¥ (' + sharedAI.participants.length + 'äºº)';
                }
                if (stateDisplay) stateDisplay.style.display = 'flex';
                if (speakerDisplay) speakerDisplay.style.display = 'block';
                if (transcriptArea) transcriptArea.style.display = 'block';
                if (chatArea) chatArea.style.display = 'block';
                if (responseArea) responseArea.style.display = 'block';
            } else {
                if (joinBtn) joinBtn.classList.remove('hidden');
                if (muteBtn) muteBtn.classList.add('hidden');
                if (leaveBtn) leaveBtn.classList.add('hidden');
                if (saveBtn) saveBtn.style.display = 'none';
                if (clearBtn) clearBtn.style.display = 'none';
                if (statusEl) {
                    statusEl.className = 'status status-disconnected';
                    statusEl.textContent = 'æœªåŠ å…¥';
                }
                if (stateDisplay) stateDisplay.style.display = 'none';
                if (speakerDisplay) speakerDisplay.style.display = 'none';
                if (transcriptArea) transcriptArea.style.display = 'none';
                if (chatArea) chatArea.style.display = 'none';
                if (responseArea) responseArea.style.display = 'none';
                // é‡ç½®éº¦å…‹é£çŠ¶æ€
                sharedAI.isMuted = false;
                if (muteBtn) {
                    muteBtn.textContent = 'ğŸ¤ å¼€éº¦';
                    muteBtn.style.background = '#28a745';
                }
                // é‡ç½®èŠå¤©è®°å½•
                sharedAI.chatMessages = [];
                sharedAI.userColors = {};
                const chatMessages = document.getElementById('shared-ai-chat-messages');
                if (chatMessages) {
                    chatMessages.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">å¼€å§‹å¯¹è¯åï¼ŒèŠå¤©è®°å½•å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>';
                }
            }

            // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
            if (participantsEl && sharedAI.participants.length > 0) {
                participantsEl.innerHTML = sharedAI.participants.map(p =>
                    `<span class="participant">${p.userName}</span>`
                ).join('');
            } else if (participantsEl) {
                participantsEl.innerHTML = '';
            }
        }

        // ç´¯ç§¯å…±äº«AIéŸ³é¢‘
        function queueSharedAIAudio(base64Audio) {
            try {
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                sharedAI.audioChunks.push(bytes);
            } catch (error) {
                console.error('[SharedAI] Failed to queue audio:', error);
            }
        }

        // æ’­æ”¾å…±äº«AIéŸ³é¢‘
        async function playSharedAIAudio() {
            if (sharedAI.audioChunks.length === 0) {
                return;
            }

            try {
                const totalLength = sharedAI.audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of sharedAI.audioChunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }

                sharedAI.audioChunks = [];

                const blob = new Blob([combined], { type: 'audio/ogg' });
                const url = URL.createObjectURL(blob);

                if (sharedAI.currentAudio) {
                    sharedAI.currentAudio.pause();
                    sharedAI.currentAudio = null;
                }

                const audio = new Audio(url);
                sharedAI.currentAudio = audio;

                updateSharedAIState('speaking', null);

                audio.onended = () => {
                    updateSharedAIState('listening', null);
                    URL.revokeObjectURL(url);
                    sharedAI.currentAudio = null;
                };

                audio.onerror = (e) => {
                    console.error('[SharedAI] Audio error:', audio.error?.message);
                    updateSharedAIState('listening', null);
                    URL.revokeObjectURL(url);
                    sharedAI.currentAudio = null;
                };

                await audio.play();
            } catch (error) {
                console.error('[SharedAI] Failed to play audio:', error);
                updateSharedAIState('listening', null);
            }
        }

        // å¤„ç†å…±äº«AIæ¶ˆæ¯
        function handleSharedAIMessage(data) {

            switch (data.type) {
                case 'shared_ai.started':
                    sharedAI.isActive = true;
                    sharedAI.isReady = true;
                    sharedAI.pendingResponse = '';
                    sharedAI.audioChunks = [];
                    updateSharedAIState('listening', null);
                    updateSharedAIUI();
                    log('[SharedAI] Shared session started');
                    requestWakeLock();
                    break;

                case 'shared_ai.joined':
                    sharedAI.isActive = true;
                    sharedAI.isReady = data.state?.isReady || false;
                    sharedAI.participants = data.state?.participants || [];
                    sharedAI.pendingResponse = '';
                    sharedAI.audioChunks = [];
                    updateSharedAIState(data.state?.isReady ? 'listening' : 'connecting', null);
                    updateSharedAIUI();
                    log('[SharedAI] Joined shared session');
                    requestWakeLock();
                    break;

                case 'shared_ai.left':
                    sharedAI.isActive = false;
                    sharedAI.isReady = false;
                    updateSharedAIUI();
                    log('[SharedAI] Left shared session');
                    if (!voiceChat.isJoined && !voiceAI.isActive) {
                        releaseWakeLock();
                    }
                    break;

                case 'shared_ai.stopped':
                    sharedAI.isActive = false;
                    sharedAI.isReady = false;
                    updateSharedAIUI();
                    log('[SharedAI] Shared session stopped');
                    if (!voiceChat.isJoined && !voiceAI.isActive) {
                        releaseWakeLock();
                    }
                    break;

                case 'shared_ai.state':
                    updateSharedAIState(data.state, data.speaker);
                    // å½“çŠ¶æ€å˜ä¸º listening æ—¶ï¼Œè¡¨ç¤º AI å›å¤ç»“æŸ
                    if (data.state === 'listening') {
                        // æ’­æ”¾ç´¯ç§¯çš„éŸ³é¢‘
                        if (sharedAI.audioChunks.length > 0) {
                            playSharedAIAudio();
                        }
                        // å°† AI å›å¤æ·»åŠ åˆ°èŠå¤©è®°å½•
                        if (sharedAI.pendingResponse && sharedAI.pendingResponse.trim()) {
                            addSharedAIChatMessage('ai', 'AIåŠ©æ‰‹', sharedAI.pendingResponse, 'ai');
                            sharedAI.pendingResponse = '';
                        }
                    }
                    break;

                case 'shared_ai.asr':
                    // æ˜¾ç¤ºè¯­éŸ³è¯†åˆ«ç»“æœ
                    const transcriptContent = document.getElementById('shared-ai-transcript-content');
                    if (transcriptContent) {
                        const speakerName = data.userName || 'Unknown';
                        if (data.isFinal) {
                            transcriptContent.innerHTML = `<span style="color: #fff;"><strong>${speakerName}:</strong> ${escapeHtml(data.text)}</span>`;
                            log(`[SharedAI] ${speakerName}: ${data.text}`);
                            // æ·»åŠ åˆ°èŠå¤©è®°å½•
                            addSharedAIChatMessage('user', speakerName, data.text, data.userId);
                        } else {
                            transcriptContent.innerHTML = `<span style="color: #aaa;"><strong>${speakerName}:</strong> ${escapeHtml(data.text)}</span>`;
                        }
                    }
                    break;

                case 'shared_ai.response':
                    // AIæ–‡æœ¬å“åº”
                    const responseContent = document.getElementById('shared-ai-response-content');
                    if (data.text) {
                        sharedAI.pendingResponse += data.text;
                        if (responseContent) {
                            responseContent.innerHTML = markdownToHtml(sharedAI.pendingResponse);
                        }
                    }
                    break;

                case 'shared_ai.audio':
                    // AIéŸ³é¢‘å“åº” - åªæœ‰å·²åŠ å…¥çš„ç”¨æˆ·æ‰æ’­æ”¾
                    if (sharedAI.isActive && data.audioData) {
                        queueSharedAIAudio(data.audioData);
                    }
                    break;

                case 'shared_ai.user_joined':
                    // æ–°ç”¨æˆ·åŠ å…¥
                    if (data.payload) {
                        sharedAI.participants.push({
                            userId: data.payload.userId,
                            userName: data.payload.userName
                        });
                        updateSharedAIUI();
                        log(`[SharedAI] ${data.payload.userName} joined (${data.payload.participantCount} participants)`);
                    }
                    break;

                case 'shared_ai.user_left':
                    // ç”¨æˆ·ç¦»å¼€
                    if (data.payload) {
                        sharedAI.participants = sharedAI.participants.filter(p => p.userId !== data.payload.userId);
                        updateSharedAIUI();
                        log(`[SharedAI] ${data.payload.userName} left (${data.payload.participantCount} participants)`);
                    }
                    break;

                case 'shared_ai.user_audio':
                    // æ”¶åˆ°å…¶ä»–ç”¨æˆ·çš„éŸ³é¢‘æ•°æ®ï¼Œæ’­æ”¾å‡ºæ¥ï¼ˆè®©ç”¨æˆ·ä¹‹é—´å¯ä»¥äº’ç›¸å¬åˆ°ï¼‰- åªæœ‰å·²åŠ å…¥çš„ç”¨æˆ·æ‰æ’­æ”¾
                    if (!sharedAI.isActive) break;
                    if (!sharedAI.userAudioFrameCount) sharedAI.userAudioFrameCount = 0
                    sharedAI.userAudioFrameCount++
                    if (sharedAI.userAudioFrameCount % 100 === 1) {
                    }
                    if (data.audioData && data.userId !== userId) {
                        handleIncomingAudio(data)
                    }
                    break;

                case 'shared_ai.error':
                    showVoiceAIError(data.message);
                    log('[SharedAI] Error: ' + data.message);
                    break;

                case 'shared_ai.context_added':
                    log('[SharedAI] Context added: ' + data.fileName);
                    break;
            }
        }

        // å¯åŠ¨è¯­éŸ³AIå¯¹è¯
        async function startVoiceAI() {
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!isAudioSupported()) {
                let errorMsg = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½ã€‚';
                if (window.location.protocol !== 'https:' && !window.isSecureContext) {
                    errorMsg += '\n\nå®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚';
                }
                alert(errorMsg);
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            // æ£€æŸ¥ HTTPSï¼ˆä»…åœ¨éå®‰å…¨ç¯å¢ƒä¸”é localhost æ—¶è­¦å‘Šï¼‰
            const isLocalhost = window.location.hostname === 'localhost' ||
                               window.location.hostname === '127.0.0.1' ||
                               window.location.hostname === '::1';
            if (window.location.protocol !== 'https:' && !window.isSecureContext && !isLocalhost) {
                alert('å®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚\nè¯·ä½¿ç”¨ https:// è®¿é—®æ­¤é¡µé¢ã€‚');
                return;
            }

            // è‡ªåŠ¨å±•å¼€è¯­éŸ³AIé¢æ¿
            const voiceAIPanel = document.getElementById('voice-ai-panel');
            const collapseBtn = document.getElementById('voice-ai-collapse-btn');
            if (voiceAIPanel.classList.contains('collapsed')) {
                voiceAIPanel.classList.remove('collapsed');
                collapseBtn.textContent = 'â–¼';
            }

            try {
                const getUserMedia = getUserMediaFunction();
                if (!getUserMedia) {
                    throw new Error('getUserMedia not available');
                }

                // è¯·æ±‚éº¦å…‹é£æƒé™
                voiceAI.mediaStream = await getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                    }
                });

                // åˆ›å»º AudioContext
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                voiceAI.audioContext = new AudioContextClass({
                    sampleRate: 16000,
                });

                const source = voiceAI.audioContext.createMediaStreamSource(voiceAI.mediaStream);

                // åˆ›å»º ScriptProcessor ç”¨äºéŸ³é¢‘å¤„ç†
                const bufferSize = 4096;
                voiceAI.audioProcessor = voiceAI.audioContext.createScriptProcessor(bufferSize, 1, 1);

                // åˆ›å»º analyser ç”¨äº VAD
                voiceAI.analyser = voiceAI.audioContext.createAnalyser();
                voiceAI.analyser.fftSize = 2048;
                source.connect(voiceAI.analyser);

                // éŸ³é¢‘ç¼“å†²åŒºï¼ˆç”¨äºç´¯ç§¯æ•°æ®ï¼Œé™ä½å‘é€é¢‘ç‡ï¼‰
                voiceAI.audioBuffer = [];
                voiceAI.lastSendTime = 0;
                const SEND_INTERVAL = 200; // æ¯ 200ms å‘é€ä¸€æ¬¡
                const MAX_BUFFER_SIZE = 16000 * 2; // æœ€å¤šç´¯ç§¯ 2 ç§’éŸ³é¢‘ (16kHz * 2s = 32000 æ ·æœ¬)

                // éŸ³é¢‘å¤„ç†å›è°ƒ
                voiceAI.audioProcessor.onaudioprocess = (event) => {
                    if (!voiceAI.isActive) return;

                    // é—­éº¦æ—¶ä¸å‘é€éŸ³é¢‘
                    if (voiceAI.isMuted) return;

                    const inputData = event.inputBuffer.getChannelData(0);

                    // VAD æ£€æµ‹
                    const isSpeech = detectVoiceAIVActivity(inputData);
                    updateVoiceAIVADIndicator(isSpeech);

                    // å°†å½“å‰æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
                    voiceAI.audioBuffer.push(...inputData);

                    // é™åˆ¶ç¼“å†²åŒºå¤§å°ï¼Œé˜²æ­¢æ— é™å¢é•¿
                    if (voiceAI.audioBuffer.length > MAX_BUFFER_SIZE) {
                        voiceAI.audioBuffer = voiceAI.audioBuffer.slice(-MAX_BUFFER_SIZE);
                    }

                    // æŒ‰æ—¶é—´é—´éš”å‘é€éŸ³é¢‘æ•°æ®
                    const now = Date.now();
                    if (now - voiceAI.lastSendTime >= SEND_INTERVAL && voiceAI.audioBuffer.length > 0) {
                        const pcmData = floatTo16BitPCM(new Float32Array(voiceAI.audioBuffer));
                        const base64Data = arrayBufferToBase64(pcmData);

                        // é™åˆ¶å•æ¬¡å‘é€æ•°æ®å¤§å°ï¼ˆæœ€å¤§ 64KB base64ï¼‰
                        if (base64Data.length <= 65536 && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'voice_ai_audio',
                                audioData: base64Data,
                            }));
                        }

                        // æ¸…ç©ºç¼“å†²åŒº
                        voiceAI.audioBuffer = [];
                        voiceAI.lastSendTime = now;
                    }
                };

                // å…ˆè®¾ç½® isActiveï¼Œç¡®ä¿éŸ³é¢‘å¤„ç†å›è°ƒèƒ½æ­£å¸¸å·¥ä½œ
                voiceAI.isActive = true;
                requestWakeLock();  // å¯ç”¨å±å¹•å¸¸äº®

                source.connect(voiceAI.audioProcessor);
                // æ³¨æ„ï¼šä¸ç›´æ¥è¿æ¥åˆ° destinationï¼Œé¿å…æœ¬åœ°å›å£°
                // åˆ›å»ºä¸€ä¸ªé™éŸ³çš„å¢ç›ŠèŠ‚ç‚¹
                const silentGain = voiceAI.audioContext.createGain();
                silentGain.gain.value = 0;  // é™éŸ³
                voiceAI.audioProcessor.connect(silentGain);
                silentGain.connect(voiceAI.audioContext.destination);

                // å‡†å¤‡å†å²èŠå¤©è®°å½•
                const chatHistory = voiceAIChatHistory.map(msg => ({
                    role: msg.role,
                    text: msg.text,
                    timestamp: msg.timestamp
                }));

                // å‡†å¤‡æ–‡ä»¶å†…å®¹
                const files = voiceAIContextFiles || [];

                // å‘é€å¼€å§‹ä¼šè¯æ¶ˆæ¯ï¼ˆåŒ…å«å†å²è®°å½•å’Œæ–‡ä»¶ï¼‰
                ws.send(JSON.stringify({
                    type: 'voice_ai_start',
                    chatHistory: chatHistory,
                    files: files
                }));
                updateVoiceAIUI();
                log('[VoiceAI] Session started');

            } catch (error) {
                console.error('[VoiceAI] Failed to start:', error);
                alert('å¯åŠ¨è¯­éŸ³AIå¤±è´¥: ' + error.message);
                showVoiceAIError(error.message);
            }
        }

        // åœæ­¢è¯­éŸ³AIå¯¹è¯
        function stopVoiceAI() {
            if (!voiceAI.isActive) return;

            // åœæ­¢éŸ³é¢‘é‡‡é›†
            if (voiceAI.audioProcessor) {
                voiceAI.audioProcessor.disconnect();
                voiceAI.audioProcessor = null;
            }

            if (voiceAI.audioContext) {
                voiceAI.audioContext.close();
                voiceAI.audioContext = null;
            }

            if (voiceAI.mediaStream) {
                voiceAI.mediaStream.getTracks().forEach(track => track.stop());
                voiceAI.mediaStream = null;
            }

            // å‘é€åœæ­¢æ¶ˆæ¯
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'voice_ai_stop',
                }));
            }

            voiceAI.isActive = false;
            voiceAI.isListening = false;
            voiceAI.isSpeaking = false;
            voiceAI.currentTranscript = '';
            voiceAI.audioBuffer = [];
            voiceAI.lastSendTime = 0;
            voiceAI.playbackQueue = [];

            // å¦‚æœæ²¡æœ‰å…¶ä»–è¯­éŸ³åŠŸèƒ½åœ¨æ´»è·ƒï¼Œé‡Šæ”¾å±å¹•å¸¸äº®
            if (!voiceChat.isJoined && !sharedAI.isActive) {
                releaseWakeLock();
            }

            updateVoiceAIUI();
            log('[VoiceAI] Session stopped');
        }

        // åˆ‡æ¢è¯­éŸ³AIéº¦å…‹é£çŠ¶æ€
        function toggleVoiceAIMute() {
            voiceAI.isMuted = !voiceAI.isMuted;
            const btn = document.getElementById('btn-voice-ai-mute');
            if (voiceAI.isMuted) {
                btn.textContent = 'ğŸ”‡ é—­éº¦';
                btn.style.background = '#dc3545';
                log('[VoiceAI] å·²é—­éº¦');
            } else {
                btn.textContent = 'ğŸ¤ å¼€éº¦';
                btn.style.background = '#28a745';
                log('[VoiceAI] å·²å¼€éº¦');
            }
        }

        // VADæ£€æµ‹
        function detectVoiceAIVActivity(floatData) {
            const energy = calculateAudioEnergy(floatData);
            const config = voiceAI.vadConfig;
            const state = voiceAI.vadState;

            state.energyHistory.push(energy);
            if (state.energyHistory.length > 10) {
                state.energyHistory.shift();
            }

            const avgEnergy = state.energyHistory.reduce((a, b) => a + b, 0) / state.energyHistory.length;
            const isCurrentlySpeech = avgEnergy > config.energyThreshold;

            if (isCurrentlySpeech) {
                state.speechCount++;
                state.silenceCount = 0;

                if (!state.isSpeech && state.speechCount >= config.minSpeechFrames) {
                    state.isSpeech = true;
                }
            } else {
                state.silenceCount++;

                if (state.isSpeech && state.silenceCount >= config.silenceFrames) {
                    state.isSpeech = false;
                    state.speechCount = 0;
                }
            }

            return state.isSpeech;
        }

        // æ›´æ–°VADæŒ‡ç¤ºå™¨
        function updateVoiceAIVADIndicator(isSpeech) {
            const dot = document.getElementById('voice-ai-state-dot');
            const text = document.getElementById('voice-ai-state-text');

            if (isSpeech) {
                if (dot) dot.style.background = '#666';
                if (text) text.textContent = 'æ­£åœ¨å¬...';
            } else {
                if (dot) dot.style.background = '#888';
                if (text) text.textContent = voiceAI.isSpeaking ? 'AIå›å¤ä¸­...' : 'ç­‰å¾…è¯´è¯...';
            }
        }

        // Float32Array è½¬ 16-bit PCM ArrayBuffer
        function floatTo16BitPCM(floatData) {
            const buffer = new ArrayBuffer(floatData.length * 2);
            const view = new DataView(buffer);
            for (let i = 0; i < floatData.length; i++) {
                let s = Math.max(-1, Math.min(1, floatData[i]));
                s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                view.setInt16(i * 2, s, true); // little-endian
            }
            return buffer;
        }

        // ArrayBuffer è½¬ Base64
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        // Base64 è½¬ ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // è¯­éŸ³AIéŸ³é¢‘ç´¯ç§¯æ’­æ”¾
        let voiceAIAudioChunks = [];
        let voiceAICurrentAudio = null;

        // ç´¯ç§¯éŸ³é¢‘å—
        function queueVoiceAIAudio(base64Audio) {
            try {
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                voiceAIAudioChunks.push(bytes);
            } catch (error) {
                console.error('[VoiceAI] Failed to queue audio:', error);
            }
        }

        // æ’­æ”¾ç´¯ç§¯çš„éŸ³é¢‘
        async function playAccumulatedAudio() {
            if (voiceAIAudioChunks.length === 0) {
                return;
            }

            try {
                // åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
                const totalLength = voiceAIAudioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of voiceAIAudioChunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }


                // æ£€æŸ¥æ ¼å¼
                if (combined[0] === 0x4F && combined[1] === 0x67 && combined[2] === 0x67 && combined[3] === 0x53) {
                } else {
                }

                // æ¸…ç©ºé˜Ÿåˆ—
                voiceAIAudioChunks = [];

                // åˆ›å»º Blob å¹¶æ’­æ”¾
                const blob = new Blob([combined], { type: 'audio/ogg' });
                const url = URL.createObjectURL(blob);

                // åœæ­¢ä¹‹å‰çš„éŸ³é¢‘
                if (voiceAICurrentAudio) {
                    voiceAICurrentAudio.pause();
                    voiceAICurrentAudio = null;
                }

                const audio = new Audio(url);
                voiceAICurrentAudio = audio;

                voiceAI.isSpeaking = true;
                updateVoiceAIState('speaking');

                audio.onended = () => {
                    voiceAI.isSpeaking = false;
                    updateVoiceAIState('listening');
                    URL.revokeObjectURL(url);
                    voiceAICurrentAudio = null;
                };

                audio.onerror = (e) => {
                    console.error('[VoiceAI] Audio error:', audio.error?.message);
                    voiceAI.isSpeaking = false;
                    updateVoiceAIState('listening');
                    URL.revokeObjectURL(url);
                    voiceAICurrentAudio = null;
                };

                await audio.play();
            } catch (error) {
                console.error('[VoiceAI] Failed to play audio:', error);
                voiceAI.isSpeaking = false;
                updateVoiceAIState('listening');
            }
        }

        // æ’­æ”¾AIéŸ³é¢‘ï¼ˆOGG/Opusæ ¼å¼ï¼‰- ä¿æŒå…¼å®¹æ€§
        async function playVoiceAIAudio(base64Audio) {
            queueVoiceAIAudio(base64Audio);
        }

        // æ›´æ–°è¯­éŸ³AIçŠ¶æ€
        function updateVoiceAIState(state) {
            const dot = document.getElementById('voice-ai-state-dot');
            const text = document.getElementById('voice-ai-state-text');

            switch (state) {
                case 'listening':
                    voiceAI.isListening = true;
                    voiceAI.isSpeaking = false;
                    if (dot) dot.style.background = '#888';
                    if (text) text.textContent = 'ç­‰å¾…è¯´è¯...';
                    break;
                case 'speaking':
                    voiceAI.isListening = false;
                    voiceAI.isSpeaking = true;
                    if (dot) dot.style.background = '#666';
                    if (text) text.textContent = 'AIå›å¤ä¸­...';
                    break;
                case 'thinking':
                    if (dot) dot.style.background = '#888';
                    if (text) text.textContent = 'AIæ€è€ƒä¸­...';
                    break;
            }
        }

        // æ›´æ–°è¯­éŸ³AI UI
        function updateVoiceAIUI() {
            const startBtn = document.getElementById('btn-voice-ai-start');
            const muteBtn = document.getElementById('btn-voice-ai-mute');
            const stopBtn = document.getElementById('btn-voice-ai-stop');
            const saveBtn = document.getElementById('btn-voice-ai-save');
            const clearBtn = document.getElementById('btn-voice-ai-clear');
            const statusEl = document.getElementById('voice-ai-status');
            const stateDisplay = document.getElementById('voice-ai-state-display');
            const chatArea = document.getElementById('voice-ai-chat-area');
            const transcriptArea = document.getElementById('voice-ai-transcript-area');
            const responseArea = document.getElementById('voice-ai-response-area');
            const controlsDiv = document.getElementById('voice-ai-controls');

            if (voiceAI.isActive) {
                if (startBtn) startBtn.classList.add('hidden');
                if (muteBtn) muteBtn.classList.remove('hidden');
                if (stopBtn) stopBtn.classList.remove('hidden');
                if (saveBtn) saveBtn.style.display = 'inline-block';
                if (clearBtn) clearBtn.style.display = 'inline-block';
                if (statusEl) {
                    statusEl.className = 'status status-connected';
                    statusEl.textContent = 'å¯¹è¯ä¸­';
                }
                if (stateDisplay) stateDisplay.style.display = 'flex';
                if (chatArea) chatArea.style.display = 'block';
                if (transcriptArea) transcriptArea.style.display = 'block';
                if (responseArea) responseArea.style.display = 'block';
                if (controlsDiv) controlsDiv.style.display = 'block';
            } else {
                if (startBtn) startBtn.classList.remove('hidden');
                if (muteBtn) muteBtn.classList.add('hidden');
                if (stopBtn) stopBtn.classList.add('hidden');
                if (statusEl) {
                    statusEl.className = 'status status-disconnected';
                    statusEl.textContent = 'æœªè¿æ¥';
                }
                if (stateDisplay) stateDisplay.style.display = 'none';
                if (transcriptArea) transcriptArea.style.display = 'none';
                if (responseArea) responseArea.style.display = 'none';
                if (controlsDiv) controlsDiv.style.display = 'none';
                // é‡ç½®éº¦å…‹é£çŠ¶æ€
                voiceAI.isMuted = false;
                if (muteBtn) {
                    muteBtn.textContent = 'ğŸ¤ å¼€éº¦';
                    muteBtn.style.background = '#28a745';
                }
            }
        }

        // æ›´æ–°è¯­éŸ³AIè½¬å½•æ–‡æœ¬
        function updateVoiceAITranscript(text, isFinal) {
            const contentEl = document.getElementById('voice-ai-transcript-content');
            if (!contentEl) return;

            if (isFinal) {
                voiceAI.currentTranscript = text;
                contentEl.innerHTML = `<span style="color: #fff;">${escapeHtml(text)}</span>`;
            } else {
                contentEl.innerHTML = `<span style="color: #aaa;">${escapeHtml(text)}</span>`;
            }
        }

        // æ›´æ–°è¯­éŸ³AIå“åº”
        function updateVoiceAIResponse(text) {
            const contentEl = document.getElementById('voice-ai-response-content');
            if (!contentEl) return;

            voiceAI.lastResponse = text;
            contentEl.innerHTML = markdownToHtml(text);
        }

        // ===========================================================================
        // è¯­éŸ³AIèŠå¤©è®°å½•åŠŸèƒ½
        // ===========================================================================

        let voiceAIChatHistory = [];
        let lastVoiceAIMessage = { text: '', timestamp: 0 }; // ç”¨äºé˜²æ­¢é‡å¤æ¶ˆæ¯
        let voiceAIContextFiles = []; // ç”¨äºå­˜å‚¨ä½œä¸ºAIä¸Šä¸‹æ–‡çš„æ–‡ä»¶

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        function addVoiceAIChatMessage(role, text) {
            if (!text || !text.trim()) return;

            const trimmedText = text.trim();
            const now = Date.now();

            // é˜²æ­¢é‡å¤ï¼šå¦‚æœæ–‡æœ¬ç›¸åŒä¸”æ—¶é—´é—´éš”å°äº3ç§’ï¼Œä¸æ·»åŠ 
            if (trimmedText === lastVoiceAIMessage.text &&
                (now - lastVoiceAIMessage.timestamp) < 3000) {
                return;
            }

            const message = {
                id: 'vai-' + now,
                role: role, // 'user' or 'ai'
                text: trimmedText,
                timestamp: new Date().toISOString()
            };

            // è®°å½•æœ€åæ·»åŠ çš„æ¶ˆæ¯
            lastVoiceAIMessage = { text: trimmedText, timestamp: now };

            voiceAIChatHistory.push(message);

            // é™åˆ¶å†å²è®°å½•å¤§å°ï¼Œé˜²æ­¢å†…å­˜å’Œå­˜å‚¨æº¢å‡º
            if (voiceAIChatHistory.length > MAX_VOICEAI_HISTORY) {
                voiceAIChatHistory = voiceAIChatHistory.slice(-MAX_VOICEAI_HISTORY);
                log(`[VoiceAI] å†å²è®°å½•å·²è£å‰ªè‡³ ${MAX_VOICEAI_HISTORY} æ¡`);
            }

            renderVoiceAIChatHistory();
            saveVoiceAIChatToLocalStorage();
        }

        // æ¸²æŸ“èŠå¤©è®°å½•
        function renderVoiceAIChatHistory() {
            const container = document.getElementById('voice-ai-chat-messages');
            const countEl = document.getElementById('voice-ai-chat-count');
            if (!container) return;

            if (countEl) {
                countEl.textContent = voiceAIChatHistory.length + ' æ¡æ¶ˆæ¯';
            }

            if (voiceAIChatHistory.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">å¼€å§‹å¯¹è¯åï¼ŒèŠå¤©è®°å½•å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>';
                return;
            }

            let html = '';
            voiceAIChatHistory.forEach(msg => {
                const time = new Date(msg.timestamp).toLocaleTimeString();
                if (msg.role === 'user') {
                    html += `
                        <div style="display: flex; justify-content: flex-start;">
                            <div style="max-width: 80%; background: #333; border-radius: 12px 12px 12px 4px; padding: 10px 14px;">
                                <div style="font-size: 11px; color: #aaa; margin-bottom: 4px;">ğŸ‘¤ ä½  Â· ${time}</div>
                                <div style="color: #fff; font-size: 14px; line-height: 1.4;">${escapeHtml(msg.text)}</div>
                            </div>
                        </div>
                    `;
                } else {
                    html += `
                        <div style="display: flex; justify-content: flex-end;">
                            <div style="max-width: 80%; background: #444; border-radius: 12px 12px 4px 12px; padding: 10px 14px;">
                                <div style="font-size: 11px; color: #aaa; margin-bottom: 4px;">ğŸ¤– AI Â· ${time}</div>
                                <div style="color: #fff; font-size: 14px; line-height: 1.4;">${markdownToHtml(msg.text)}</div>
                            </div>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
            container.scrollTop = container.scrollHeight;
        }

        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        function saveVoiceAIChatToLocalStorage() {
            try {
                const data = JSON.stringify(voiceAIChatHistory);
                // æ£€æŸ¥å¤§å°ï¼Œè¶…è¿‡é™åˆ¶åˆ™è£å‰ª
                if (data.length > MAX_LOCALSTORAGE_SIZE / 2) {  // ç•™ä¸€åŠç©ºé—´ç»™å…¶ä»–æ•°æ®
                    // è£å‰ªåˆ°ä¸€åŠå¤§å°
                    const targetSize = voiceAIChatHistory.length / 2;
                    voiceAIChatHistory = voiceAIChatHistory.slice(-Math.floor(targetSize));
                    log(`[VoiceAI] localStorage ç©ºé—´ä¸è¶³ï¼Œè£å‰ªå†å²è®°å½•è‡³ ${voiceAIChatHistory.length} æ¡`);
                }
                localStorage.setItem('voiceAI_chatHistory', JSON.stringify(voiceAIChatHistory));
            } catch (e) {
                console.error('[VoiceAI] Failed to save chat history:', e);
                // å¦‚æœå­˜å‚¨å¤±è´¥ï¼Œå°è¯•æ¸…é™¤æ—§æ•°æ®
                if (e.name === 'QuotaExceededError') {
                    voiceAIChatHistory = voiceAIChatHistory.slice(-20);  // åªä¿ç•™æœ€è¿‘20æ¡
                    try {
                        localStorage.setItem('voiceAI_chatHistory', JSON.stringify(voiceAIChatHistory));
                        log('[VoiceAI] å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œå·²æ¸…ç†æ—§è®°å½•');
                    } catch (e2) {
                        log('[VoiceAI] æ— æ³•ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                    }
                }
            }
        }

        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
        function loadVoiceAIChatFromLocalStorage() {
            try {
                const saved = localStorage.getItem('voiceAI_chatHistory');
                if (saved) {
                    voiceAIChatHistory = JSON.parse(saved);
                    renderVoiceAIChatHistory();
                }
                // åŠ è½½ä¸Šä¸‹æ–‡æ–‡ä»¶
                const savedFiles = localStorage.getItem('voiceAI_contextFiles');
                if (savedFiles) {
                    voiceAIContextFiles = JSON.parse(savedFiles);
                    renderVoiceAIContextFiles();
                }
            } catch (e) {
                console.error('[VoiceAI] Failed to load chat history:', e);
            }
        }

        // ===========================================================================
        // è¯­éŸ³AIä¸Šä¸‹æ–‡æ–‡ä»¶ç®¡ç†
        // ===========================================================================

        // æ·»åŠ æ–‡ä»¶åˆ°AIä¸Šä¸‹æ–‡
        async function addVoiceAIContextFile(file) {
            try {
                // æ£€æŸ¥æ–‡ä»¶æ•°é‡é™åˆ¶
                if (voiceAIContextFiles.length >= MAX_CONTEXT_FILES) {
                    alert(`ä¸Šä¸‹æ–‡æ–‡ä»¶æ•°é‡å·²è¾¾ä¸Šé™ (${MAX_CONTEXT_FILES} ä¸ª)ï¼Œè¯·å…ˆåˆ é™¤éƒ¨åˆ†æ–‡ä»¶`);
                    return;
                }

                const content = await readFileAsText(file);
                voiceAIContextFiles.push({
                    name: file.name,
                    content: content,
                    type: 'text'
                });
                saveVoiceAIContextFiles();
                renderVoiceAIContextFiles();
                log(`[VoiceAI] Added context file: ${file.name}`);
            } catch (error) {
                console.error('[VoiceAI] Failed to add context file:', error);
                alert('æ·»åŠ æ–‡ä»¶å¤±è´¥: ' + error.message);
            }
        }

        // è¯»å–æ–‡ä»¶å†…å®¹ä¸ºæ–‡æœ¬
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // æ·»åŠ ç²˜è´´çš„æ–‡æœ¬åˆ°AIä¸Šä¸‹æ–‡
        async function addVoiceAIPastedText() {
            const textarea = document.getElementById('voice-ai-paste-text');

            const content = textarea.value.trim();
            if (!content) {
                alert('è¯·å…ˆç²˜è´´æ–‡æœ¬å†…å®¹');
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶æ•°é‡é™åˆ¶
            if (voiceAIContextFiles.length >= MAX_CONTEXT_FILES) {
                alert(`ä¸Šä¸‹æ–‡æ–‡ä»¶æ•°é‡å·²è¾¾ä¸Šé™ (${MAX_CONTEXT_FILES} ä¸ª)ï¼Œè¯·å…ˆåˆ é™¤éƒ¨åˆ†æ–‡ä»¶`);
                return;
            }

            // é™åˆ¶æ–‡æœ¬é•¿åº¦ï¼ˆæœ€å¤§ 500KBï¼‰
            if (content.length > 500 * 1024) {
                alert('æ–‡æœ¬å†…å®¹ä¸èƒ½è¶…è¿‡ 500KB');
                return;
            }

            // è‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å
            const date = new Date().toISOString().slice(0, 10);
            const time = new Date().toTimeString().slice(0, 5).replace(':', '-');
            const fileName = `ç²˜è´´æ–‡æœ¬_${date}_${time}.txt`;

            // æ£€æŸ¥æ˜¯å¦å¤„äºæ´»è·ƒçš„è¯­éŸ³AIä¼šè¯ä¸­
            if (voiceAI.isActive && ws && ws.readyState === WebSocket.OPEN) {
                // æ´»è·ƒä¼šè¯ä¸­ï¼Œç›´æ¥å‘é€æ–‡æœ¬ç»™AIï¼ˆä¼šè§¦å‘AIå›å¤ï¼‰

                ws.send(JSON.stringify({
                    type: 'voice_ai_text',
                    text: content
                }));

                // åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°åˆ—è¡¨ï¼ˆç”¨äºæ˜¾ç¤ºå’Œåç»­ä¼šè¯ï¼‰
                voiceAIContextFiles.push({
                    name: fileName,
                    content: content,
                    type: 'text'
                });
                saveVoiceAIContextFiles();
                renderVoiceAIContextFiles();

                log(`[VoiceAI] æ–‡æœ¬å·²å‘é€ç»™AIï¼Œç­‰å¾…å›å¤...`);
            } else {
                // æœªåœ¨å¯¹è¯ä¸­ï¼Œä»…ä¿å­˜åˆ°æœ¬åœ°
                voiceAIContextFiles.push({
                    name: fileName,
                    content: content,
                    type: 'text'
                });

                saveVoiceAIContextFiles();
                renderVoiceAIContextFiles();

                log(`[VoiceAI] Added pasted text: ${fileName} (${content.length} chars)`);
            }

            // æ¸…ç©ºè¾“å…¥æ¡†
            textarea.value = '';
        }

        // ç§»é™¤ä¸Šä¸‹æ–‡æ–‡ä»¶
        function removeVoiceAIContextFile(index) {
            if (index >= 0 && index < voiceAIContextFiles.length) {
                const file = voiceAIContextFiles[index];
                voiceAIContextFiles.splice(index, 1);
                saveVoiceAIContextFiles();
                renderVoiceAIContextFiles();
                log(`[VoiceAI] Removed context file: ${file.name}`);
            }
        }

        // ä¿å­˜ä¸Šä¸‹æ–‡æ–‡ä»¶åˆ°æœ¬åœ°å­˜å‚¨
        function saveVoiceAIContextFiles() {
            try {
                localStorage.setItem('voiceAI_contextFiles', JSON.stringify(voiceAIContextFiles));
            } catch (e) {
                console.error('[VoiceAI] Failed to save context files:', e);
            }
        }

        // æ¸²æŸ“ä¸Šä¸‹æ–‡æ–‡ä»¶åˆ—è¡¨
        function renderVoiceAIContextFiles() {
            const container = document.getElementById('voice-ai-context-files');
            if (!container) return;

            if (voiceAIContextFiles.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 8px;">';
            html += '<div style="font-size: 12px; color: #888; margin-bottom: 8px;">ä¸Šä¸‹æ–‡æ–‡ä»¶:</div>';
            voiceAIContextFiles.forEach((file, index) => {
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: #333; border-radius: 4px; margin-bottom: 4px;">
                        <span style="font-size: 12px; color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px;">${escapeHtml(file.name)}</span>
                        <button onclick="removeVoiceAIContextFile(${index})" style="background: #dc3545; border: none; color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">ç§»é™¤</button>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        async function handleVoiceAIFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶1MBï¼‰
            if (file.size > 1024 * 1024) {
                alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 1MB');
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            const allowedTypes = [
                'text/plain', 'text/markdown', 'text/javascript', 'text/typescript',
                'application/json', 'text/yaml', 'text/xml', 'text/html', 'text/css',
                'application/javascript', 'application/typescript'
            ];
            const allowedExtensions = ['.txt', '.md', '.js', '.ts', '.py', '.json', '.yaml', '.yml', '.xml', '.html', '.css'];
            const hasAllowedExtension = allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));

            if (!hasAllowedExtension) {
                alert('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚è¯·é€‰æ‹©æ–‡æœ¬æ–‡ä»¶ã€‚');
                return;
            }

            await addVoiceAIContextFile(file);

            // æ¸…ç©ºinputä»¥ä¾¿å†æ¬¡é€‰æ‹©åŒä¸€æ–‡ä»¶
            event.target.value = '';
        }

        // ä¿å­˜èŠå¤©è®°å½•åˆ°æ–‡ä»¶
        function saveVoiceAIChat() {
            if (voiceAIChatHistory.length === 0) {
                alert('æ²¡æœ‰èŠå¤©è®°å½•å¯ä¿å­˜');
                return;
            }

            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10);
            const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-');

            let content = `# è¯­éŸ³AIå¯¹è¯è®°å½•\n`;
            content += `# å¯¼å‡ºæ—¶é—´: ${now.toLocaleString()}\n`;
            content += `# æ¶ˆæ¯æ•°é‡: ${voiceAIChatHistory.length}\n\n`;
            content += `---\n\n`;

            voiceAIChatHistory.forEach(msg => {
                const time = new Date(msg.timestamp).toLocaleString();
                if (msg.role === 'user') {
                    content += `### ğŸ‘¤ ä½  (${time})\n\n${msg.text}\n\n`;
                } else {
                    content += `### ğŸ¤– AI (${time})\n\n${msg.text}\n\n`;
                }
            });

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voice-ai-chat-${dateStr}_${timeStr}.md`;
            a.click();
            URL.revokeObjectURL(url);

            log('[VoiceAI] èŠå¤©è®°å½•å·²ä¿å­˜');
        }

        // æ¸…ç©ºèŠå¤©è®°å½•
        function clearVoiceAIChat() {
            if (voiceAIChatHistory.length === 0) return;

            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿ')) return;

            voiceAIChatHistory = [];
            renderVoiceAIChatHistory();
            localStorage.removeItem('voiceAI_chatHistory');
            log('[VoiceAI] èŠå¤©è®°å½•å·²æ¸…ç©º');
        }

        // æ˜¾ç¤ºè¯­éŸ³AIé”™è¯¯
        function showVoiceAIError(message) {
            const errorEl = document.getElementById('voice-ai-error');
            if (errorEl) {
                errorEl.textContent = 'é”™è¯¯: ' + message;
                errorEl.style.display = 'block';
                setTimeout(() => {
                    errorEl.style.display = 'none';
                }, 5000);
            }
        }

        // å¤„ç†è¯­éŸ³AIæ¶ˆæ¯
        function handleVoiceAIMessage(data) {

            switch (data.type) {
                case 'voice_ai.started':
                    voiceAI.isActive = true;
                    voiceAI.pendingAIResponse = ''; // æ¸…ç©ºç´¯ç§¯çš„AIå“åº”
                    updateVoiceAIState('listening');
                    updateVoiceAIResponse(''); // æ¸…ç©ºAIå›å¤æ˜¾ç¤º
                    log('[VoiceAI] Session started successfully');
                    // åŠ è½½æœ¬åœ°èŠå¤©è®°å½•
                    loadVoiceAIChatFromLocalStorage();
                    break;

                case 'voice_ai.stopped':
                    voiceAI.isActive = false;
                    // å¦‚æœæ²¡æœ‰å…¶ä»–è¯­éŸ³åŠŸèƒ½åœ¨æ´»è·ƒï¼Œé‡Šæ”¾å±å¹•å¸¸äº®
                    if (!voiceChat.isJoined && !sharedAI.isActive) {
                        releaseWakeLock();
                    }
                    updateVoiceAIUI();
                    log('[VoiceAI] Session stopped');
                    break;

                case 'voice_ai.asr':
                    // è¯­éŸ³è¯†åˆ«ç»“æœ
                    updateVoiceAITranscript(data.text, data.isFinal);
                    if (data.isFinal) {
                        log('[VoiceAI] ASR Final: ' + data.text);
                        // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                        addVoiceAIChatMessage('user', data.text);
                    }
                    break;

                case 'voice_ai.response':
                    // AIæ–‡æœ¬å“åº”ï¼ˆæµå¼ï¼Œæ¯æ¬¡å¯èƒ½åªè¿”å›ä¸€ä¸ªå­—ç¬¦ï¼‰
                    // ç´¯ç§¯AIå“åº”æ–‡æœ¬
                    if (data.text) {
                        if (!voiceAI.pendingAIResponse) {
                            voiceAI.pendingAIResponse = '';
                        }
                        voiceAI.pendingAIResponse += data.text;
                        // æ›´æ–°æ˜¾ç¤ºç´¯ç§¯çš„å®Œæ•´æ–‡æœ¬
                        updateVoiceAIResponse(voiceAI.pendingAIResponse);
                    }
                    break;

                case 'voice_ai.audio':
                    // AIéŸ³é¢‘å“åº” - ç´¯ç§¯éŸ³é¢‘å—
                    if (data.audioData) {
                        queueVoiceAIAudio(data.audioData);
                    }
                    break;

                case 'voice_ai.state':
                    // çŠ¶æ€å˜åŒ–
                    updateVoiceAIState(data.state);
                    // å½“çŠ¶æ€å˜ä¸º listening æ—¶ï¼Œè¡¨ç¤º TTS ç»“æŸï¼Œæ’­æ”¾ç´¯ç§¯çš„éŸ³é¢‘
                    if (data.state === 'listening' && voiceAIAudioChunks.length > 0) {
                        playAccumulatedAudio();
                        // æ·»åŠ å®Œæ•´çš„AIå“åº”åˆ°èŠå¤©è®°å½•
                        if (voiceAI.pendingAIResponse && voiceAI.pendingAIResponse.trim()) {
                            addVoiceAIChatMessage('ai', voiceAI.pendingAIResponse);
                            voiceAI.pendingAIResponse = '';
                        }
                    }
                    break;

                case 'voice_ai.error':
                    // é”™è¯¯
                    showVoiceAIError(data.message);
                    log('[VoiceAI] Error: ' + data.message);
                    break;

                case 'voice_ai.context_added':
                    // åŠ¨æ€ä¸Šä¸‹æ–‡æ·»åŠ æˆåŠŸ
                    log('[VoiceAI] âœ“ ' + data.message + ' (' + data.length + ' å­—ç¬¦)');
                    break;

                default:
            }
        }

        // ===========================================================================
        // è¯­éŸ³èŠå¤©åŠŸèƒ½ - æ”¹é€ ç‰ˆï¼ˆæŒç»­é‡‡é›† + VAD æ£€æµ‹ï¼‰
        // ===========================================================================

        let voiceChat = {
            isJoined: false,
            isMuted: false,  // éº¦å…‹é£çŠ¶æ€
            isSpeaking: false,  // æœ¬åœ°æ˜¯å¦æ£€æµ‹åˆ°è¯­éŸ³ï¼ˆVADï¼‰
            isServerSpeaking: false,  // æœåŠ¡ç«¯ç¡®è®¤çš„å‘è¨€çŠ¶æ€
            paused: false,  // æš‚åœéŸ³é¢‘å‘é€ï¼ˆå½“ @AI æŒ‰é’® ASR ä½¿ç”¨æ—¶ï¼‰
            audioContext: null,
            mediaStream: null,
            audioProcessor: null,
            analyser: null,
            participants: new Map(),
            transcripts: [],
            currentTranscripts: new Map(), // å½“å‰æ­£åœ¨è¿›è¡Œçš„è½¬å½•ï¼ˆæŒ‰userIdï¼‰
            // VAD é…ç½®
            vadConfig: {
                energyThreshold: 0.01,      // èƒ½é‡é˜ˆå€¼ï¼ˆ0-1ä¹‹é—´ï¼‰
                silenceFrames: 20,          // è¿ç»­å¤šå°‘å¸§é™éŸ³è®¤ä¸ºæ˜¯ç»“æŸ
                minSpeechFrames: 5,         // æœ€å°‘å¤šå°‘å¸§æ‰ç®—æœ‰æ•ˆè¯­éŸ³
                frameSize: 4096,            // æ¯å¸§æ ·æœ¬æ•°
            },
            vadState: {
                energyHistory: [],
                silenceCount: 0,
                speechCount: 0,
                isSpeech: false,
            },
            // Web Speech API (æµè§ˆå™¨æœ¬åœ°è¯­éŸ³è¯†åˆ«)
            useWebSpeech: false,  // ç¦ç”¨Web Speech APIï¼Œä½¿ç”¨æœåŠ¡ç«¯ASRé¿å…é‡å¤è¯†åˆ«
            webSpeechRecognition: null,
            webSpeechTranscript: '',
            isWebSpeechActive: false,
            // éŸ³é¢‘æ’­æ”¾ç›¸å…³ï¼ˆæ¥æ”¶å…¶ä»–ç”¨æˆ·éŸ³é¢‘ï¼‰
            playbackAudioContext: null,  // ç”¨äºæ’­æ”¾çš„ç‹¬ç«‹AudioContext
            audioPlaybackBuffers: new Map(),  // ç”¨æˆ·éŸ³é¢‘ç¼“å†²åŒº Map<userId, Float32Array[]>
            playbackProcessors: new Map(),    // ç”¨æˆ·æ’­æ”¾å¤„ç†å™¨ Map<userId, ScriptProcessorNode>
            playbackReadPos: new Map(),       // ç”¨æˆ·æ’­æ”¾è¯»å–ä½ç½® Map<userId, number>
            playbackRingBuffer: new Map(),    // ç”¨æˆ·ç¯å½¢ç¼“å†²åŒº Map<userId, Float32Array>
            RING_BUFFER_SIZE: 65536,          // ç¯å½¢ç¼“å†²åŒºå¤§å°ï¼ˆçº¦4ç§’@16kHzï¼‰
            isPlayingAudio: new Map(),        // æ˜¯å¦æ­£åœ¨æ’­æ”¾ Map<userId, boolean>
            lastAudioTime: new Map(),         // æœ€åæ¥æ”¶éŸ³é¢‘æ—¶é—´ Map<userId, number>
            audioPlaybackEnabled: true,       // æ˜¯å¦å¯ç”¨éŸ³é¢‘æ’­æ”¾
        };

        // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒéŸ³é¢‘å½•åˆ¶
        function isAudioSupported() {
            // æ£€æŸ¥æ˜¯å¦æ”¯æŒ getUserMediaï¼ˆå¤„ç†å„ç§å‰ç¼€ï¼‰
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||
                                   !!(navigator.getUserMedia) ||
                                   !!(navigator.webkitGetUserMedia) ||
                                   !!(navigator.mozGetUserMedia);

            // æ£€æŸ¥æ˜¯å¦æ”¯æŒ Web Audio API
            const hasWebAudio = !!(window.AudioContext || window.webkitAudioContext);

            // è¿”å›æ”¯æŒçŠ¶æ€

            return hasGetUserMedia && hasWebAudio;
        }

        // æ£€æŸ¥æ˜¯å¦æ”¯æŒ Web Speech API
        function isWebSpeechSupported() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            return !!SpeechRecognition;
        }

        // åˆå§‹åŒ– Web Speech API
        function initWebSpeech() {
            if (!voiceChat.useWebSpeech) return false;
            if (!isWebSpeechSupported()) {
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            voiceChat.webSpeechRecognition = new SpeechRecognition();

            // é…ç½®è¯­éŸ³è¯†åˆ«
            voiceChat.webSpeechRecognition.continuous = true;
            voiceChat.webSpeechRecognition.interimResults = true;
            voiceChat.webSpeechRecognition.lang = 'zh-CN'; // è®¾ç½®ä¸­æ–‡è¯†åˆ«

            voiceChat.webSpeechRecognition.onstart = () => {
                voiceChat.isWebSpeechActive = true;
            };

            voiceChat.webSpeechRecognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // å¤„ç†è¯†åˆ«ç»“æœ
                if (finalTranscript) {
                    handleWebSpeechResult(finalTranscript, true);
                } else if (interimTranscript) {
                    handleWebSpeechResult(interimTranscript, false);
                }
            };

            voiceChat.webSpeechRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.error('[WebSpeech] Error:', event.error);
                }
                voiceChat.isWebSpeechActive = false;

                // å¦‚æœè¿˜åœ¨è¯­éŸ³èŠå¤©ä¸­ï¼Œå°è¯•é‡å¯è¯†åˆ«
                if (voiceChat.isJoined && voiceChat.useWebSpeech) {
                    setTimeout(() => {
                        if (voiceChat.isJoined) startWebSpeech();
                    }, 500);
                }
            };

            voiceChat.webSpeechRecognition.onend = () => {
                voiceChat.isWebSpeechActive = false;

                // å¦‚æœè¿˜åœ¨è¯­éŸ³èŠå¤©ä¸­ï¼Œè‡ªåŠ¨é‡å¯
                if (voiceChat.isJoined && voiceChat.useWebSpeech) {
                    setTimeout(() => {
                        if (voiceChat.isJoined) startWebSpeech();
                    }, 100);
                }
            };

            return true;
        }

        // å¯åŠ¨ Web Speech è¯†åˆ«
        function startWebSpeech() {
            if (!voiceChat.useWebSpeech || !voiceChat.webSpeechRecognition) return;
            if (voiceChat.isWebSpeechActive) return;

            try {
                voiceChat.webSpeechRecognition.start();
            } catch (e) {
                console.error('[WebSpeech] Failed to start:', e);
            }
        }

        // åœæ­¢ Web Speech è¯†åˆ«
        function stopWebSpeech() {
            if (!voiceChat.webSpeechRecognition) return;
            if (!voiceChat.isWebSpeechActive) return;

            try {
                voiceChat.webSpeechRecognition.stop();
            } catch (e) {
                console.error('[WebSpeech] Failed to stop:', e);
            }
        }

        // å¤„ç† Web Speech è¯†åˆ«ç»“æœ
        // é˜²é‡å¤æœºåˆ¶
        let lastSentText = '';
        let lastSentTime = 0;
        const DUPLICATE_THRESHOLD = 3000; // 3ç§’å†…çš„é‡å¤æ£€æµ‹çª—å£

        function handleWebSpeechResult(text, isFinal) {
            if (!text.trim()) return;

            const trimmedText = text.trim();

            // åªåœ¨æœ€ç»ˆç»“æœæ—¶å‘é€åˆ°æœåŠ¡å™¨
            if (isFinal && ws && ws.readyState === WebSocket.OPEN) {
                const now = Date.now();
                const timeSinceLastSent = now - lastSentTime;

                // æ£€æŸ¥æ˜¯å¦åœ¨æ—¶é—´çª—å£å†…
                if (timeSinceLastSent < DUPLICATE_THRESHOLD) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤æˆ–åŒ…å«å…³ç³»
                    // å¦‚æœæ–°æ–‡æœ¬åŒ…å«æ—§æ–‡æœ¬ï¼Œæˆ–æ—§æ–‡æœ¬åŒ…å«æ–°æ–‡æœ¬ï¼Œè·³è¿‡
                    if (trimmedText.includes(lastSentText) || lastSentText.includes(trimmedText)) {
                        // å¦‚æœæ–°æ–‡æœ¬æ›´é•¿ï¼Œæ›¿æ¢æ—§æ–‡æœ¬
                        if (trimmedText.length > lastSentText.length) {
                            lastSentText = trimmedText;
                            lastSentTime = now;
                        }
                        return;
                    }
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¤§é‡é‡å ï¼ˆè¶…è¿‡70%å­—ç¬¦ç›¸åŒï¼‰
                    const shorterLen = Math.min(trimmedText.length, lastSentText.length);
                    let matchCount = 0;
                    for (let i = 0; i < shorterLen; i++) {
                        if (trimmedText[i] === lastSentText[i]) matchCount++;
                    }
                    if (shorterLen > 0 && matchCount / shorterLen > 0.7) {
                        if (trimmedText.length > lastSentText.length) {
                            lastSentText = trimmedText;
                            lastSentTime = now;
                        }
                        return;
                    }
                }

                // æ›´æ–°æœ€åå‘é€çš„è®°å½•
                lastSentText = trimmedText;
                lastSentTime = now;

                // æ˜¾ç¤ºè½¬å½•ç»“æœ
                addVoiceTranscript({
                    id: 'webspeech_' + Date.now(),
                    userId: userId,
                    userName: currentUser?.name || 'æˆ‘',
                    text: trimmedText,
                    timestamp: now,
                    isFinal: true,
                });

                // å‘é€åˆ°æœåŠ¡å™¨
                ws.send(JSON.stringify({
                    type: 'voice_transcript',
                    transcript: {
                        text: trimmedText,
                        isFinal: true,
                        source: 'webspeech'
                    }
                }));
            } else if (!isFinal) {
                // ä¸´æ—¶ç»“æœåªåœ¨æœ¬åœ°æ˜¾ç¤º
                addVoiceTranscript({
                    id: 'webspeech_' + Date.now(),
                    userId: userId,
                    userName: currentUser?.name || 'æˆ‘',
                    text: trimmedText,
                    timestamp: Date.now(),
                    isFinal: false,
                });
            }
        }

        // è·å– getUserMedia å‡½æ•°ï¼ˆå¤„ç†æµè§ˆå™¨å…¼å®¹æ€§ï¼‰
        function getUserMediaFunction() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                return navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            }
            const legacyGetUserMedia = navigator.getUserMedia ||
                                       navigator.webkitGetUserMedia ||
                                       navigator.mozGetUserMedia;
            if (legacyGetUserMedia) {
                return function(constraints) {
                    return new Promise((resolve, reject) => {
                        legacyGetUserMedia.call(navigator, constraints, resolve, reject);
                    });
                };
            }
            return null;
        }

        // è®¡ç®—éŸ³é¢‘èƒ½é‡ï¼ˆç”¨äºVADï¼‰
        function calculateAudioEnergy(floatData) {
            let sum = 0;
            for (let i = 0; i < floatData.length; i++) {
                sum += floatData[i] * floatData[i];
            }
            return Math.sqrt(sum / floatData.length);
        }

        // VAD æ£€æµ‹
        function detectVoiceActivity(floatData) {
            const energy = calculateAudioEnergy(floatData);
            const config = voiceChat.vadConfig;
            const state = voiceChat.vadState;

            // æ›´æ–°å†å²
            state.energyHistory.push(energy);
            if (state.energyHistory.length > 10) {
                state.energyHistory.shift();
            }

            // ä½¿ç”¨å¹³æ»‘åçš„èƒ½é‡å€¼
            const avgEnergy = state.energyHistory.reduce((a, b) => a + b, 0) / state.energyHistory.length;
            const isCurrentlySpeech = avgEnergy > config.energyThreshold;

            if (isCurrentlySpeech) {
                state.speechCount++;
                state.silenceCount = 0;

                if (!state.isSpeech && state.speechCount >= config.minSpeechFrames) {
                    state.isSpeech = true;
                }
            } else {
                state.silenceCount++;

                if (state.isSpeech && state.silenceCount >= config.silenceFrames) {
                    state.isSpeech = false;
                    state.speechCount = 0;
                }
            }

            return state.isSpeech;
        }

        // åŠ å…¥è¯­éŸ³èŠå¤© - ç«‹å³å¼€å§‹æŒç»­éŸ³é¢‘é‡‡é›†
        async function joinVoiceChat() {
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!isAudioSupported()) {
                const protocol = window.location.protocol;
                const isSecure = window.isSecureContext;

                let errorMsg = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åŠŸèƒ½ã€‚';
                if (protocol !== 'https:' && !isSecure) {
                    errorMsg += '\n\nå®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚';
                    errorMsg += '\nè¯·ä½¿ç”¨ https:// è®¿é—®æ­¤é¡µé¢ã€‚';
                }

                alert(errorMsg);
                console.error('[Voice] Browser not supported:', {
                    protocol,
                    isSecureContext: isSecure,
                    userAgent: navigator.userAgent
                });
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨');
                return;
            }

            // æ£€æŸ¥ HTTPSï¼ˆä»…åœ¨éå®‰å…¨ç¯å¢ƒä¸”é localhost æ—¶è­¦å‘Šï¼‰
            const isLocalhost = window.location.hostname === 'localhost' ||
                               window.location.hostname === '127.0.0.1' ||
                               window.location.hostname === '::1';
            if (window.location.protocol !== 'https:' && !window.isSecureContext && !isLocalhost) {
                alert('å®‰å“æµè§ˆå™¨éœ€è¦ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚\nè¯·ä½¿ç”¨ https:// è®¿é—®æ­¤é¡µé¢ã€‚');
                return;
            }

            try {
                const getUserMedia = getUserMediaFunction();
                if (!getUserMedia) {
                    throw new Error('getUserMedia not available');
                }

                // è¯·æ±‚éº¦å…‹é£æƒé™
                voiceChat.mediaStream = await getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                    }
                });

                log('éº¦å…‹é£æƒé™å·²è·å–ï¼Œæ­£åœ¨åˆå§‹åŒ–éŸ³é¢‘...');

                // ç«‹å³åˆå§‹åŒ–éŸ³é¢‘å¤„ç†ï¼ˆæŒç»­é‡‡é›†ï¼‰
                await initContinuousAudioProcessing();

                // åˆå§‹åŒ– Web Speech APIï¼ˆæµè§ˆå™¨æœ¬åœ°è¯­éŸ³è¯†åˆ«ï¼‰
                if (initWebSpeech()) {
                    log('æµè§ˆå™¨è¯­éŸ³è¯†åˆ«å·²å¯ç”¨');
                    startWebSpeech();
                } else {
                    log('æµè§ˆå™¨è¯­éŸ³è¯†åˆ«ä¸å¯ç”¨ï¼Œä»…ä½¿ç”¨æœåŠ¡ç«¯è¯­éŸ³è¯†åˆ«');
                }

                // å‘é€åŠ å…¥è¯­éŸ³èŠå¤©è¯·æ±‚
                ws.send(JSON.stringify({ type: 'voice_join' }));

            } catch (error) {
                console.error('è·å–éº¦å…‹é£æƒé™å¤±è´¥:', error);

                let errorMsg = 'æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®';
                if (error.name === 'NotAllowedError') {
                    errorMsg = 'éº¦å…‹é£æƒé™è¢«æ‹’ç»ã€‚è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®éº¦å…‹é£ã€‚';
                } else if (error.name === 'NotFoundError') {
                    errorMsg = 'æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡ã€‚';
                } else if (error.name === 'NotSupportedError') {
                    errorMsg = 'æµè§ˆå™¨ä¸æ”¯æŒè¯¥éŸ³é¢‘æ ¼å¼ã€‚';
                }

                alert(errorMsg);
            }
        }

        // ç¦»å¼€è¯­éŸ³èŠå¤©
        function leaveVoiceChat() {
            if (!voiceChat.isJoined) return;

            // åœæ­¢éŸ³é¢‘æµ
            if (voiceChat.mediaStream) {
                voiceChat.mediaStream.getTracks().forEach(track => track.stop());
                voiceChat.mediaStream = null;
            }

            // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (voiceChat.audioContext) {
                voiceChat.audioContext.close();
                voiceChat.audioContext = null;
            }

            // å…³é—­æ’­æ”¾éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (voiceChat.playbackAudioContext) {
                // åœæ­¢æ‰€æœ‰æ’­æ”¾å¤„ç†å™¨
                stopAllPlayback();
                voiceChat.playbackAudioContext.close();
                voiceChat.playbackAudioContext = null;
            }

            // é‡ç½®çŠ¶æ€
            voiceChat.audioProcessor = null;
            voiceChat.analyser = null;
            voiceChat.isSpeaking = false;
            voiceChat.isServerSpeaking = false;
            voiceChat.audioBuffer = [];

            // æ¸…ç†éŸ³é¢‘æ’­æ”¾ç›¸å…³çŠ¶æ€
            voiceChat.audioPlaybackBuffers.clear();
            voiceChat.playbackProcessors.clear();
            voiceChat.playbackRingBuffer.clear();
            voiceChat.playbackReadPos.clear();
            voiceChat.isPlayingAudio.clear();
            voiceChat.lastAudioTime.clear();

            // åœæ­¢ Web Speech è¯†åˆ«
            stopWebSpeech();

            // å‘é€ç¦»å¼€è¯·æ±‚
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'voice_leave' }));
            }

            // é‡ç½®çŠ¶æ€
            voiceChat.isJoined = false;
            voiceChat.participants.clear();
            voiceChat.transcripts = [];
            voiceChat.currentTranscripts.clear();

            // å¦‚æœæ²¡æœ‰å…¶ä»–è¯­éŸ³åŠŸèƒ½åœ¨æ´»è·ƒï¼Œé‡Šæ”¾å±å¹•å¸¸äº®
            if (!sharedAI.isActive && !voiceAI.isActive) {
                releaseWakeLock();
            }

            // é‡ç½® VAD
            voiceChat.vadState = {
                energyHistory: [],
                silenceCount: 0,
                speechCount: 0,
                isSpeech: false,
            };

            // æ›´æ–°UI
            updateVoiceChatUI();
            log('å·²ç¦»å¼€è¯­éŸ³èŠå¤©');
        }

        // åˆ‡æ¢è¯­éŸ³èŠå¤©éº¦å…‹é£çŠ¶æ€
        function toggleVoiceChatMute() {
            voiceChat.isMuted = !voiceChat.isMuted;
            const btn = document.getElementById('btn-voice-mute');
            if (voiceChat.isMuted) {
                btn.textContent = 'ğŸ”‡ é—­éº¦';
                btn.style.background = '#dc3545';
                log('è¯­éŸ³èŠå¤©: å·²é—­éº¦');
            } else {
                btn.textContent = 'ğŸ¤ å¼€éº¦';
                btn.style.background = '#28a745';
                log('è¯­éŸ³èŠå¤©: å·²å¼€éº¦');
            }
        }

        // åˆå§‹åŒ–æŒç»­éŸ³é¢‘å¤„ç†ï¼ˆå¸¦ VADï¼‰
        async function initContinuousAudioProcessing() {
            if (!voiceChat.mediaStream) return;

            // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
            voiceChat.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });

            const source = voiceChat.audioContext.createMediaStreamSource(voiceChat.mediaStream);

            // åˆ›å»ºåˆ†æå™¨ç”¨äº VAD
            voiceChat.analyser = voiceChat.audioContext.createAnalyser();
            voiceChat.analyser.fftSize = 256;
            source.connect(voiceChat.analyser);

            // åˆ›å»ºè„šæœ¬å¤„ç†å™¨ï¼ˆç”¨äºè·å–åŸå§‹éŸ³é¢‘æ•°æ®ï¼‰
            const bufferSize = voiceChat.vadConfig.frameSize;
            voiceChat.audioProcessor = voiceChat.audioContext.createScriptProcessor(bufferSize, 1, 1);

            // éŸ³é¢‘ç¼“å†²åŒºå’Œå‘é€æ§åˆ¶
            voiceChat.audioBuffer = [];
            voiceChat.lastSendTime = 0;
            voiceChat.sendInterval = 50; // æ¯ 50ms å‘é€ä¸€æ¬¡ï¼ˆä¼˜åŒ–å»¶è¿Ÿï¼‰
            voiceChat.maxBufferSize = 4000; // æœ€å¤§ç¼“å†²åŒºå¤§å°ï¼ˆçº¦250ms @16kHzï¼‰

            voiceChat.audioProcessor.onaudioprocess = (event) => {
                if (!voiceChat.isJoined) return;

                // é—­éº¦æ—¶ä¸å‘é€éŸ³é¢‘
                if (voiceChat.isMuted) return;

                // è·å–éŸ³é¢‘æ•°æ®
                const inputData = event.inputBuffer.getChannelData(0);

                // VAD æ£€æµ‹
                const isSpeech = detectVoiceActivity(inputData);

                // å¦‚æœæœ¬åœ° VAD çŠ¶æ€å˜åŒ–ï¼Œæ›´æ–° UI
                if (isSpeech !== voiceChat.isSpeaking) {
                    voiceChat.isSpeaking = isSpeech;
                    updateVoiceSpeakingUI(isSpeech);
                }

                // å°†å½“å‰æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
                voiceChat.audioBuffer.push(...inputData);

                // é™åˆ¶ç¼“å†²åŒºå¤§å°
                if (voiceChat.audioBuffer.length > voiceChat.maxBufferSize) {
                    voiceChat.audioBuffer = voiceChat.audioBuffer.slice(-voiceChat.maxBufferSize);
                }

                // æŒ‰æ—¶é—´é—´éš”å‘é€éŸ³é¢‘æ•°æ®
                const now = Date.now();
                if (now - voiceChat.lastSendTime >= voiceChat.sendInterval && voiceChat.audioBuffer.length > 0) {
                    // è½¬æ¢ä¸º 16-bit PCM
                    const pcmData = floatTo16BitPCM(new Float32Array(voiceChat.audioBuffer));
                    const base64Audio = arrayBufferToBase64(pcmData);

                    // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€åˆ°è¯­éŸ³AI
                    if (chatVoiceAI.isActive) {
                        // å‘é€åˆ°èŠå¤©å®¤è¯­éŸ³AI
                        if (base64Audio.length <= 32768 && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'chat_voice_ai_audio',
                                audioData: base64Audio,
                                isSpeaking: isSpeech
                            }));
                        }
                    } else if (!voiceChat.paused) {
                        // å‘é€åˆ°è¯­éŸ³èŠå¤© ASRï¼ˆå¦‚æœæœªæš‚åœï¼‰
                        if (base64Audio.length <= 32768 && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'voice_continuous_audio',
                                audioData: base64Audio,
                                isSpeech: isSpeech
                            }));
                        }
                    }

                    // æ¸…ç©ºç¼“å†²åŒº
                    voiceChat.audioBuffer = [];
                    voiceChat.lastSendTime = now;
                }
            };

            source.connect(voiceChat.audioProcessor);
            // æ³¨æ„ï¼šä¸è¿æ¥åˆ° destinationï¼Œé¿å…æœ¬åœ°å›å£°
            // éŸ³é¢‘å¤„ç†å™¨éœ€è¦è¿æ¥æŸä¸ªè¾“å‡ºæ‰èƒ½è§¦å‘ onaudioprocess äº‹ä»¶
            // ä½†æˆ‘ä»¬ä¸éœ€è¦å¬åˆ°è‡ªå·±çš„å£°éŸ³ï¼Œæ‰€ä»¥åˆ›å»ºä¸€ä¸ªé™éŸ³çš„å¢ç›ŠèŠ‚ç‚¹
            const silentGain = voiceChat.audioContext.createGain();
            silentGain.gain.value = 0;  // é™éŸ³
            voiceChat.audioProcessor.connect(silentGain);
            silentGain.connect(voiceChat.audioContext.destination);

            log('æŒç»­éŸ³é¢‘é‡‡é›†å·²å¯åŠ¨ï¼ˆå¸¦ VAD æ£€æµ‹ï¼‰');
        }

        // Float32 è½¬ 16-bit PCM
        function floatTo16BitPCM(floatData) {
            const buffer = new ArrayBuffer(floatData.length * 2);
            const view = new DataView(buffer);

            for (let i = 0; i < floatData.length; i++) {
                let s = Math.max(-1, Math.min(1, floatData[i]));
                s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                view.setInt16(i * 2, s, true);
            }

            return buffer;
        }

        // ArrayBuffer è½¬ Base64
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        // è§¦å‘ AI åˆ†æ
        function voiceAIAnalyze() {
            if (!voiceChat.isJoined) {
                alert('è¯·å…ˆåŠ å…¥è¯­éŸ³èŠå¤©');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            ws.send(JSON.stringify({ type: 'voice_ai_analyze' }));
            log('è¯·æ±‚AIåˆ†æè¯­éŸ³èŠå¤©å†…å®¹');
        }

        // æ›´æ–°è¯­éŸ³èŠå¤© UI
        function updateVoiceChatUI() {
            const statusEl = document.getElementById('voice-status');
            const joinBtn = document.getElementById('btn-voice-join');
            const muteBtn = document.getElementById('btn-voice-mute');
            const leaveBtn = document.getElementById('btn-voice-leave');
            const controlsEl = document.getElementById('voice-controls');
            const transcriptArea = document.getElementById('voice-transcript-area');
            const chatVoiceAISection = document.getElementById('chat-voice-ai-section');

            if (voiceChat.isJoined) {
                statusEl.className = 'status status-connected';
                statusEl.textContent = 'å·²è¿æ¥';
                joinBtn.classList.add('hidden');
                muteBtn.classList.remove('hidden');
                leaveBtn.classList.remove('hidden');
                controlsEl.style.display = 'block';
                transcriptArea.style.display = 'block';
                // æ˜¾ç¤ºè¯­éŸ³AIåŒºåŸŸ
                if (chatVoiceAISection) chatVoiceAISection.style.display = 'block';
            } else {
                statusEl.className = 'status status-disconnected';
                statusEl.textContent = 'æœªè¿æ¥';
                joinBtn.classList.remove('hidden');
                muteBtn.classList.add('hidden');
                leaveBtn.classList.add('hidden');
                controlsEl.style.display = 'none';
                transcriptArea.style.display = 'none';
                // éšè—è¯­éŸ³AIåŒºåŸŸå¹¶åœæ­¢è¯­éŸ³AI
                if (chatVoiceAISection) chatVoiceAISection.style.display = 'none';
                if (chatVoiceAI.isActive) {
                    stopChatVoiceAI();
                }
                document.getElementById('voice-transcript-content').innerHTML = '';
                voiceChat.transcripts = [];
                // é‡ç½®éº¦å…‹é£çŠ¶æ€
                voiceChat.isMuted = false;
                muteBtn.textContent = 'ğŸ¤ å¼€éº¦';
                muteBtn.style.background = '#28a745';
            }

            updateVoiceParticipantsUI();
        }

        // æ›´æ–°å½•éŸ³çŠ¶æ€ UI
        function updateVoiceSpeakingUI(isSpeaking) {
            const indicator = document.getElementById('voice-speaking-indicator');
            const vadDot = document.getElementById('vad-status-dot');
            const vadText = document.getElementById('vad-status-text');

            if (isSpeaking) {
                if (indicator) indicator.style.display = 'flex';
                if (vadDot) {
                    vadDot.style.background = '#666';
                    vadDot.style.boxShadow = '0 0 10px #666';
                }
                if (vadText) vadText.textContent = 'æ£€æµ‹åˆ°è¯­éŸ³';
                if (vadText) vadText.style.color = '#666';
            } else {
                if (indicator) indicator.style.display = 'none';
                if (vadDot) {
                    vadDot.style.background = '#888';
                    vadDot.style.boxShadow = 'none';
                }
                if (vadText) vadText.textContent = 'æœªæ£€æµ‹åˆ°è¯­éŸ³';
                if (vadText) vadText.style.color = '#888';
            }
        }

        // æ›´æ–°å‚ä¸è€…åˆ—è¡¨ UI
        function updateVoiceParticipantsUI() {
            const container = document.getElementById('voice-participants');

            if (!voiceChat.isJoined || voiceChat.participants.size === 0) {
                container.innerHTML = '<span style="color: #fff; font-size: 12px;">æš‚æ— å‚ä¸è€…</span>';
                return;
            }

            container.innerHTML = Array.from(voiceChat.participants.values()).map(p => {
                const isSpeaking = p.isSpeaking;
                return `
                    <div class="voice-participant ${isSpeaking ? 'speaking' : ''}">
                        <span>${isSpeaking ? 'ğŸ”Š' : 'ğŸ¤'}</span>
                        <span>${p.userName}</span>
                        ${isSpeaking ? '<span style="color: #fff;">(å‘è¨€ä¸­)</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        // æ·»åŠ è½¬å½•æ–‡æœ¬
        function addVoiceTranscript(transcript) {
            // å¦‚æœæ˜¯æœ€ç»ˆç»“æœï¼Œç§»é™¤ä¹‹å‰çš„ä¸´æ—¶ç»“æœ
            if (transcript.isFinal) {
                const tempIndex = voiceChat.transcripts.findIndex(t =>
                    t.userId === transcript.userId && !t.isFinal
                );
                if (tempIndex >= 0) {
                    voiceChat.transcripts.splice(tempIndex, 1);
                }
            }

            voiceChat.transcripts.push(transcript);

            // åªä¿ç•™æœ€è¿‘30æ¡
            if (voiceChat.transcripts.length > 30) {
                voiceChat.transcripts.shift();
            }

            renderVoiceTranscripts();
        }

        // æ›´æ–°å½“å‰è½¬å½•ï¼ˆéæœ€ç»ˆç»“æœï¼‰
        function updateCurrentTranscript(transcript) {
            const key = transcript.userId;
            voiceChat.currentTranscripts.set(key, transcript);
            renderVoiceTranscripts();
        }

        // æ¸²æŸ“è½¬å½•æ–‡æœ¬
        function renderVoiceTranscripts() {
            const container = document.getElementById('voice-transcript-content');

            // åˆå¹¶å†å²è½¬å½•å’Œå½“å‰è½¬å½•
            const allTranscripts = [...voiceChat.transcripts];

            // æ·»åŠ å½“å‰æ­£åœ¨è¿›è¡Œçš„è½¬å½•
            voiceChat.currentTranscripts.forEach((transcript, userId) => {
                // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¯¥ç”¨æˆ·çš„æœ€ç»ˆç»“æœ
                const hasFinal = voiceChat.transcripts.some(t =>
                    t.userId === userId && t.isFinal &&
                    Math.abs(t.timestamp - transcript.timestamp) < 5000
                );
                if (!hasFinal) {
                    allTranscripts.push(transcript);
                }
            });

            // æŒ‰æ—¶é—´æ’åº
            allTranscripts.sort((a, b) => a.timestamp - b.timestamp);

            container.innerHTML = allTranscripts.map(t => `
                <div class="voice-transcript-item ${t.isFinal ? 'voice-transcript-final' : ''}">
                    <span class="voice-transcript-speaker">${t.userName}:</span>
                    <span class="voice-transcript-text">${t.text}${!t.isFinal ? ' <span style="color: #fff;">(è¯†åˆ«ä¸­...)</span>' : ''}</span>
                </div>
            `).join('');

            // æ»šåŠ¨åˆ°åº•éƒ¨
            container.parentElement.scrollTop = container.parentElement.scrollHeight;
        }

        // å¤„ç†è¯­éŸ³èŠå¤©æœåŠ¡å™¨æ¶ˆæ¯
        function handleVoiceMessage(data) {
            switch (data.type) {
                case 'voice.join':
                    if (data.success) {
                        // è‡ªå·±åŠ å…¥æˆåŠŸ - å°†è‡ªå·±æ·»åŠ åˆ°å‚ä¸è€…åˆ—è¡¨
                        voiceChat.isJoined = true;
                        voiceChat.participants.set(userId, {
                            userId: userId,
                            userName: currentUser?.name || 'æˆ‘',
                            isSpeaking: false
                        });
                        updateVoiceChatUI();
                        log('å·²åŠ å…¥è¯­éŸ³èŠå¤©');
                        // å¯ç”¨å±å¹•å¸¸äº®
                        requestWakeLock();
                    } else if (data.userId && data.userId !== userId) {
                        // å…¶ä»–ç”¨æˆ·åŠ å…¥
                        voiceChat.participants.set(data.userId, {
                            userId: data.userId,
                            userName: data.userName,
                            isSpeaking: false
                        });
                        updateVoiceParticipantsUI();
                        log(`${data.userName || 'æœ‰äºº'} åŠ å…¥äº†è¯­éŸ³èŠå¤©`);
                    }
                    break;

                case 'voice.asr_ready':
                    log('è¯­éŸ³è¯†åˆ«æœåŠ¡å·²å°±ç»ª');
                    break;

                case 'voice.leave':
                    if (data.success) {
                        // è‡ªå·±ç¦»å¼€æˆåŠŸ
                        voiceChat.isJoined = false;
                        voiceChat.participants.clear();
                        updateVoiceChatUI();
                        log('å·²ç¦»å¼€è¯­éŸ³èŠå¤©');
                    } else if (data.userId && data.userId !== userId) {
                        // å…¶ä»–ç”¨æˆ·ç¦»å¼€
                        voiceChat.participants.delete(data.userId);
                        updateVoiceParticipantsUI();
                        log(`${data.userName || 'æœ‰äºº'} ç¦»å¼€äº†è¯­éŸ³èŠå¤©`);
                    }
                    break;

                case 'voice.speaking.start':
                    // æœåŠ¡ç«¯ç¡®è®¤æŸç”¨æˆ·å¼€å§‹å‘è¨€
                    voiceChat.participants.set(data.userId, {
                        userId: data.userId,
                        userName: data.userName,
                        isSpeaking: true
                    });
                    updateVoiceParticipantsUI();
                    if (data.userId !== userId) {
                        log(`${data.userName} å¼€å§‹å‘è¨€`);
                    }
                    break;

                case 'voice.speaking.end':
                    // æœåŠ¡ç«¯ç¡®è®¤æŸç”¨æˆ·åœæ­¢å‘è¨€
                    const p = voiceChat.participants.get(data.userId);
                    if (p) {
                        p.isSpeaking = false;
                    }
                    updateVoiceParticipantsUI();
                    break;

                case 'voice.transcript':
                    // å®æ—¶è½¬å½•ç»“æœï¼ˆéæœ€ç»ˆï¼‰
                    updateCurrentTranscript(data.transcript);
                    break;

                case 'voice.transcript.final':
                    // æœ€ç»ˆè½¬å½•ç»“æœ
                    voiceChat.currentTranscripts.delete(data.userId);
                    addVoiceTranscript(data.transcript);
                    log(`[è¯­éŸ³] ${data.transcript.userName}: ${data.transcript.text}`);

                    // å°†è¯­éŸ³è½¬å½•æ·»åŠ åˆ°ä¸»èŠå¤©å®¤å¯¹è¯ä¸­
                    const voiceMessage = {
                        id: data.transcript.id || `voice_${Date.now()}`,
                        type: 'text',
                        content: `ğŸ¤ ${data.transcript.text}`,
                        senderId: data.transcript.userId,
                        senderName: data.transcript.userName || data.userName || 'æœªçŸ¥ç”¨æˆ·',
                        senderRole: 'member',
                        timestamp: data.transcript.timestamp || Date.now(),
                        isVoiceTranscript: true
                    };
                    addMessage(voiceMessage, data.transcript.userId === userId, autoScrollEnabled && !isUserScrollingUp);
                    break;

                case 'voice.ai_analyze':
                    if (data.status === 'analyzing') {
                        addSystemMessage(`ğŸ¤– ${data.triggeredByName || 'æœ‰äºº'} è¯·æ±‚AIåˆ†æè¯­éŸ³å†…å®¹...`);
                        log('AIæ­£åœ¨åˆ†æè¯­éŸ³å†…å®¹...');
                    } else if (data.status === 'completed') {
                        log('AIåˆ†æå®Œæˆ');
                    } else if (data.status === 'error') {
                        addSystemMessage(`AIåˆ†æå¤±è´¥: ${data.error}`);
                        log(`AIåˆ†æå¤±è´¥: ${data.error}`);
                    }
                    break;

                case 'voice.error':
                    console.error('è¯­éŸ³èŠå¤©é”™è¯¯:', data.error, data.message);
                    const errorEl = document.getElementById('voice-error');
                    errorEl.textContent = data.message || 'è¯­éŸ³èŠå¤©å‡ºé”™';
                    errorEl.style.display = 'block';
                    setTimeout(() => {
                        errorEl.style.display = 'none';
                    }, 5000);
                    break;

                case 'voice.status':
                    if (data.room) {
                        // æ›´æ–°æˆ¿é—´çŠ¶æ€
                        data.room.participants?.forEach(p => {
                            voiceChat.participants.set(p.userId, p);
                        });
                        updateVoiceParticipantsUI();
                    }
                    break;

                case 'voice.audio':
                    // æ”¶åˆ°å…¶ä»–ç”¨æˆ·çš„éŸ³é¢‘æ•°æ®ï¼Œæ’­æ”¾å‡ºæ¥
                    handleIncomingAudio(data);
                    break;
            }
        }

        // ===========================================================================
        // éŸ³é¢‘æ¥æ”¶å’Œæ’­æ”¾åŠŸèƒ½ï¼ˆè¯­éŸ³å¯¹è®²ï¼‰
        // ===========================================================================

        /**
         * å¤„ç†æ”¶åˆ°çš„éŸ³é¢‘æ•°æ®
         */
        function handleIncomingAudio(data) {

            if (!voiceChat.audioPlaybackEnabled) {
                console.log('[Audio] Playback disabled');
                return;
            }
            if (!data.audioData || !data.userId) {
                console.log('[Audio] No audio data or userId');
                return;
            }

            const senderId = data.userId;
            const senderName = data.userName || 'æœªçŸ¥ç”¨æˆ·';

            // ä¸æ’­æ”¾è‡ªå·±çš„éŸ³é¢‘ï¼ˆé¿å…å›å£°ï¼‰
            if (senderId === userId) {
                return;
            }


            try {
                // Base64 è§£ç ä¸º ArrayBuffer
                const binary = atob(data.audioData);

                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // å°† 16-bit PCM è½¬æ¢ä¸º Float32 éŸ³é¢‘æ•°æ®
                const pcmData = new Int16Array(bytes.buffer);

                const floatData = new Float32Array(pcmData.length);
                for (let i = 0; i < pcmData.length; i++) {
                    floatData[i] = pcmData[i] / 32768.0;  // 16-bit to float (-1 to 1)
                }

                // åˆå§‹åŒ–æ’­æ”¾éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                initPlaybackAudioContext();

                // è°ƒè¯•ï¼šæ‰“å°æ¥æ”¶åˆ°çš„éŸ³é¢‘ä¿¡æ¯
                if (!voiceChat.audioFrameCount) voiceChat.audioFrameCount = 0;
                voiceChat.audioFrameCount++;
                if (voiceChat.audioFrameCount % 50 === 1) {
                    console.log(`[Audio] Received audio from ${senderName}, samples: ${floatData.length}`);
                }

                // æ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ—
                queueAudioForPlayback(senderId, senderName, floatData);

                // æ›´æ–°æœ€åæ¥æ”¶éŸ³é¢‘æ—¶é—´
                voiceChat.lastAudioTime.set(senderId, Date.now());

            } catch (error) {
                console.error('[Audio Playback] handleIncomingAudio: FAILED -', error);
            }
        }

        /**
         * åˆå§‹åŒ–æ’­æ”¾ç”¨çš„ AudioContext
         */
        function initPlaybackAudioContext() {
            if (voiceChat.playbackAudioContext) return;

            try {
                voiceChat.playbackAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });
            } catch (error) {
                console.error('[Audio Playback] Failed to initialize AudioContext:', error);
            }
        }

        /**
         * åˆå§‹åŒ–ç”¨æˆ·çš„æ’­æ”¾å¤„ç†å™¨ï¼ˆä½¿ç”¨ ScriptProcessorNode å®ç°è¿ç»­æ’­æ”¾ï¼‰
         */
        function initUserPlaybackProcessor(userId) {
            if (!voiceChat.playbackAudioContext) {
                console.log('[Audio] No playbackAudioContext');
                return;
            }
            if (voiceChat.playbackProcessors.has(userId)) {
                console.log('[Audio] Processor already exists for', userId);
                return;
            }

            console.log('[Audio] Creating playback processor for', userId);

            // åˆ›å»ºç¯å½¢ç¼“å†²åŒº
            const ringBuffer = new Float32Array(voiceChat.RING_BUFFER_SIZE);
            voiceChat.playbackRingBuffer.set(userId, ringBuffer);
            voiceChat.playbackReadPos.set(userId, 0);
            voiceChat.audioPlaybackBuffers.set(userId, { writePos: 0 });

            // åˆ›å»º ScriptProcessorNode ç”¨äºè¿ç»­æ’­æ”¾
            const processor = voiceChat.playbackAudioContext.createScriptProcessor(4096, 0, 1);

            processor.onaudioprocess = (event) => {
                const output = event.outputBuffer.getChannelData(0);
                const buffer = voiceChat.playbackRingBuffer.get(userId);
                const posData = voiceChat.audioPlaybackBuffers.get(userId);

                if (!buffer || !posData) {
                    output.fill(0);
                    return;
                }

                let readPos = voiceChat.playbackReadPos.get(userId);
                const writePos = posData.writePos;

                // è®¡ç®—å¯ç”¨æ•°æ®é‡
                let available = writePos - readPos;
                if (available < 0) {
                    available += voiceChat.RING_BUFFER_SIZE;
                }

                if (available >= output.length) {
                    // æœ‰è¶³å¤Ÿæ•°æ®ï¼Œæ­£å¸¸æ’­æ”¾
                    for (let i = 0; i < output.length; i++) {
                        output[i] = buffer[readPos];
                        readPos = (readPos + 1) % voiceChat.RING_BUFFER_SIZE;
                    }
                    voiceChat.playbackReadPos.set(userId, readPos);
                    voiceChat.isPlayingAudio.set(userId, true);
                } else if (available > 0) {
                    // æ•°æ®ä¸è¶³ï¼Œæ’­æ”¾å¯ç”¨æ•°æ®ï¼Œå…¶ä½™é™éŸ³
                    for (let i = 0; i < output.length; i++) {
                        if (i < available) {
                            output[i] = buffer[readPos];
                            readPos = (readPos + 1) % voiceChat.RING_BUFFER_SIZE;
                        } else {
                            output[i] = 0;
                        }
                    }
                    voiceChat.playbackReadPos.set(userId, readPos);
                } else {
                    // æ²¡æœ‰æ•°æ®ï¼Œè¾“å‡ºé™éŸ³
                    output.fill(0);
                    voiceChat.isPlayingAudio.set(userId, false);
                }
            };

            // è¿æ¥åˆ°è¾“å‡º
            const gainNode = voiceChat.playbackAudioContext.createGain();
            gainNode.gain.value = 0.9;
            processor.connect(gainNode);
            gainNode.connect(voiceChat.playbackAudioContext.destination);

            voiceChat.playbackProcessors.set(userId, processor);
            console.log('[Audio] Playback processor created for', userId);
        }

        /**
         * å°†éŸ³é¢‘æ•°æ®åŠ å…¥æ’­æ”¾é˜Ÿåˆ—ï¼ˆå†™å…¥ç¯å½¢ç¼“å†²åŒºï¼‰
         */
        function queueAudioForPlayback(userId, userName, floatData) {
            if (!voiceChat.playbackAudioContext) return;

            // ç¡®ä¿ç”¨æˆ·æœ‰æ’­æ”¾å¤„ç†å™¨
            if (!voiceChat.playbackProcessors.has(userId)) {
                initUserPlaybackProcessor(userId);
            }

            const buffer = voiceChat.playbackRingBuffer.get(userId);
            const posData = voiceChat.audioPlaybackBuffers.get(userId);

            if (!buffer || !posData) return;

            // å†™å…¥ç¯å½¢ç¼“å†²åŒº
            let writePos = posData.writePos;
            for (let i = 0; i < floatData.length; i++) {
                buffer[writePos] = floatData[i];
                writePos = (writePos + 1) % voiceChat.RING_BUFFER_SIZE;
            }
            posData.writePos = writePos;

            // æ›´æ–°æœ€åæ¥æ”¶æ—¶é—´
            voiceChat.lastAudioTime.set(userId, Date.now());

            // æ›´æ–°è¯´è¯çŠ¶æ€
            const participant = voiceChat.participants.get(userId);
            if (participant) {
                updateVoiceParticipantSpeaking(userId, participant.userName, true);
            }
        }

        /**
         * åœæ­¢ç”¨æˆ·çš„æ’­æ”¾å¤„ç†å™¨
         */
        function stopUserPlaybackProcessor(userId) {
            const processor = voiceChat.playbackProcessors.get(userId);
            if (processor) {
                processor.disconnect();
                voiceChat.playbackProcessors.delete(userId);
            }
            voiceChat.playbackRingBuffer.delete(userId);
            voiceChat.playbackReadPos.delete(userId);
            voiceChat.audioPlaybackBuffers.delete(userId);
            voiceChat.isPlayingAudio.delete(userId);
        }

        /**
         * åœæ­¢æ‰€æœ‰æ’­æ”¾
         */
        function stopAllPlayback() {
            for (const [userId] of voiceChat.playbackProcessors) {
                stopUserPlaybackProcessor(userId);
            }
        }

        /**
         * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¿˜åœ¨è¯´è¯
         */
        function checkSpeakingStatus(userId, userName) {
            const lastTime = voiceChat.lastAudioTime.get(userId) || 0;
            const now = Date.now();

            // å¦‚æœè¶…è¿‡500msæ²¡æœ‰æ”¶åˆ°éŸ³é¢‘ï¼Œè®¤ä¸ºåœæ­¢è¯´è¯
            if (now - lastTime > 500) {
                updateVoiceParticipantSpeaking(userId, userName, false);
                // é‡ç½®æ’­æ”¾çŠ¶æ€ï¼Œä¸‹æ¬¡è¯´è¯æ—¶é‡æ–°é¢„ç¼“å†²
                voiceChat.playbackStarted.set(userId, false);
                voiceChat.nextPlayTime.set(userId, 0);
                // æ¸…ç©ºç¼“å†²åŒº
                const buffers = voiceChat.audioPlaybackBuffers.get(userId);
                if (buffers) {
                    buffers.length = 0;
                }
            }
        }

        /**
         * æ›´æ–°å‚ä¸è€…è¯´è¯çŠ¶æ€UI
         */
        function updateVoiceParticipantSpeaking(userId, userName, isSpeaking) {
            const participant = voiceChat.participants.get(userId);
            if (participant) {
                participant.isSpeaking = isSpeaking;
                updateVoiceParticipantsUI();
            }
        }

        // ===========================================================================
        // é‚€è¯·äºŒç»´ç å’Œéšæœºç”¨æˆ·ååŠŸèƒ½
        // ===========================================================================

        // å½¢å®¹è¯å’Œåè¯åº“ï¼Œç”¨äºç”Ÿæˆéšæœºç”¨æˆ·å
        const ADJECTIVES = ['å¿«ä¹', 'èªæ˜', 'å‹‡æ•¢', 'æ¸©æŸ”', 'æœºæ™º', 'æ´»æ³¼', 'å–„è‰¯', 'å¯çˆ±', 'å¸…æ°”', 'ç¾ä¸½', 'ç¥ç§˜', 'é…·ç‚«', 'é˜³å…‰', 'å¹½é»˜', 'å‹¤å¥‹'];
        const NOUNS = ['ç†ŠçŒ«', 'çŒ«å’ª', 'ç‹—ç‹—', 'å…”å­', 'è€è™', 'ç‹®å­', 'ç‹ç‹¸', 'æ¾é¼ ', 'å°é¸Ÿ', 'é±¼å„¿', 'æ˜Ÿæ˜Ÿ', 'æœˆäº®', 'å¤ªé˜³', 'äº‘æœµ', 'å½©è™¹', 'å¤§ä¾ ', 'ä¾ å®¢', 'å¿è€…', 'éª‘å£«', 'æ³•å¸ˆ'];

        let currentQRCode = null;
        let inviteCode = null;

        // ç”Ÿæˆéšæœºç”¨æˆ·å
        function generateRandomName() {
            const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
            const randomNum = Math.floor(Math.random() * 1000);
            const name = `${adj}${ noun}${randomNum}`;
            document.getElementById('user-name').value = name;
            log(`å·²ç”Ÿæˆéšæœºç”¨æˆ·å: ${name}`);
        }

        // ç”Ÿæˆé‚€è¯·ç 
        function generateInviteCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // ç”ŸæˆäºŒç»´ç 
        function generateQRCode() {
            const sessionId = document.getElementById('session-id').value;
            if (!sessionId) return;

            inviteCode = generateInviteCode();
            const baseUrl = window.location.origin + window.location.pathname;
            let inviteUrl = `${baseUrl}?room=${encodeURIComponent(sessionId)}&invite=${inviteCode}`;

            // å¦‚æœå‹¾é€‰äº†"åŒ…å«å¯†ç "ï¼Œæ·»åŠ å¯†ç å‚æ•°
            const includePassword = document.getElementById('include-password').checked;
            if (includePassword && pendingPasswordQuestion && pendingPasswordAnswer) {
                inviteUrl += `&pwd=${encodeURIComponent(pendingPasswordAnswer)}`;
            }

            // æ¸…é™¤æ—§çš„äºŒç»´ç 
            const qrcodeDiv = document.getElementById('qrcode');
            qrcodeDiv.innerHTML = '';

            // ç”Ÿæˆæ–°çš„äºŒç»´ç 
            currentQRCode = new QRCode(qrcodeDiv, {
                text: inviteUrl,
                width: 100,
                height: 100,
                colorDark: '#666',
                colorLight: '#1a1a1a',
                correctLevel: QRCode.CorrectLevel.M
            });

            // ä¿å­˜é‚€è¯·é“¾æ¥åˆ° data å±æ€§
            qrcodeDiv.setAttribute('data-invite-url', inviteUrl);
        }

        // å¤åˆ¶é‚€è¯·é“¾æ¥
        function copyInviteLink() {
            const sessionId = document.getElementById('session-id').value;
            if (!sessionId) {
                alert('è¯·å…ˆç”ŸæˆäºŒç»´ç ');
                return;
            }

            const baseUrl = window.location.origin + window.location.pathname;
            const code = inviteCode || generateInviteCode();
            let inviteUrl = `${baseUrl}?room=${encodeURIComponent(sessionId)}&invite=${code}`;

            // å¦‚æœå‹¾é€‰äº†"åŒ…å«å¯†ç "ï¼Œæ·»åŠ å¯†ç å‚æ•°
            const includePassword = document.getElementById('include-password').checked;
            if (includePassword && pendingPasswordQuestion && pendingPasswordAnswer) {
                inviteUrl += `&pwd=${encodeURIComponent(pendingPasswordAnswer)}`;
            }

            navigator.clipboard.writeText(inviteUrl).then(() => {
                alert('é‚€è¯·é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                log('é‚€è¯·é“¾æ¥å·²å¤åˆ¶');
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                // é™çº§æ–¹æ¡ˆ
                const textarea = document.createElement('textarea');
                textarea.value = inviteUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('é‚€è¯·é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            });
        }

        // ä¸‹è½½äºŒç»´ç 
        function downloadQRCode() {
            const qrcodeDiv = document.getElementById('qrcode');
            const img = qrcodeDiv.querySelector('img');
            if (img && img.src) {
                const link = document.createElement('a');
                link.download = `chat-invite-${inviteCode || 'code'}.png`;
                link.href = img.src;
                link.click();
                log('äºŒç»´ç å·²ä¸‹è½½');
            } else {
                alert('äºŒç»´ç ç”Ÿæˆä¸­ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // è§£æURLå‚æ•°å¹¶è‡ªåŠ¨å¡«å†™
        function parseUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            const inviteParam = urlParams.get('invite');
            const pwdAnswerParam = urlParams.get('pwd'); // é‚€è¯·é“¾æ¥ä¸­çš„å¯†ç ç­”æ¡ˆ

            if (roomParam) {
                document.getElementById('session-id').value = roomParam;
                log(`å·²ä»é‚€è¯·é“¾æ¥åŠ è½½æˆ¿é—´: ${roomParam}`);
                if (inviteParam) {
                    log(`é‚€è¯·ç : ${inviteParam}`);
                }
                // å¦‚æœé‚€è¯·é“¾æ¥åŒ…å«å¯†ç ï¼Œä¿å­˜åˆ° pending å˜é‡
                if (pwdAnswerParam) {
                    pendingPasswordAnswer = pwdAnswerParam;
                    log('é‚€è¯·é“¾æ¥åŒ…å«æˆ¿é—´å¯†ç ');
                }
            }
        }

        // é¡µé¢åŠ è½½æ—¶è§£æURLå‚æ•°
        parseUrlParams();

        // ç›‘å¬æˆ¿é—´IDå˜åŒ–ï¼Œç”ŸæˆäºŒç»´ç 
        const sessionIdInput = document.getElementById('session-id');
        sessionIdInput.addEventListener('change', generateQRCode);
        sessionIdInput.addEventListener('input', debounce(generateQRCode, 500));

        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥å¯†ç è¾“å…¥æ¡†
    </script>
</body>
</html>